<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/11/12/nodejs-start/"/>
    <url>/2021/11/12/nodejs-start/</url>
    
    <content type="html"><![CDATA[<h1 id="NodeJs系列之开篇"><a href="#NodeJs系列之开篇" class="headerlink" title="NodeJs系列之开篇"></a>NodeJs系列之开篇</h1><p>nodejs系列分几大板块从浅到深学习nodejs</p><ul><li>(一)nodejs的模块化机制</li><li>(二)nodejs中的EventLoop</li><li>(三)nodejs核心模块</li><li>(四)手写koa</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于AST实现一个简易的webpack</title>
    <link href="/2021/03/14/ast-webpack/"/>
    <url>/2021/03/14/ast-webpack/</url>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>了解webpack如何实现commonjs规范。</li><li>分析webpack打包后生成的文件</li><li>基于AST实现webpack打包js文件。  <blockquote><p>运行环境：<br>nodejs：v10.15.3<br>webpack：4.26.0<br>webpack-cli： 3.3.12  </p></blockquote><h2 id="分析webpack打包结果"><a href="#分析webpack打包结果" class="headerlink" title="分析webpack打包结果"></a>分析webpack打包结果</h2>打包的结果是一个闭包，参数就是模块的依赖对象（也可以是数组），key为文件的路径，value是一个function,模块内部代码使用function进行包裹。  <h2 id="了解webpack如何实现commonjs规范"><a href="#了解webpack如何实现commonjs规范" class="headerlink" title="了解webpack如何实现commonjs规范"></a>了解webpack如何实现commonjs规范</h2></li></ul><ol><li>使用__webpack_require__代替require</li><li>__webpack_require__内部构造出module.exports,记录模块的导出内容。  </li></ol><pre><code class="hljs js">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>)</span>&#123;    <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = (installedModules[moduleId] = &#123;      i: moduleId,      l: <span class="hljs-literal">false</span>,      <span class="hljs-built_in">exports</span>: &#123;&#125;,    &#125;);    <span class="hljs-comment">//调用挂载的function，开始运行程序</span>    modules[moduleId].call(<span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);    <span class="hljs-comment">//返回模块导出的内容。</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;&#125;</code></pre><h2 id="提取webpack的Template模板"><a href="#提取webpack的Template模板" class="headerlink" title="提取webpack的Template模板"></a>提取webpack的Template模板</h2><pre><code class="hljs js">  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">modules</span>) </span>&#123;  <span class="hljs-comment">// webpackBootstrap</span>  <span class="hljs-comment">// 模块缓存</span>  <span class="hljs-keyword">var</span> installedModules = &#123;&#125;;  <span class="hljs-comment">// The require function</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>&#123;    <span class="hljs-comment">// Check if module is in cache</span>    <span class="hljs-keyword">if</span> (installedModules[moduleId]) &#123;      <span class="hljs-keyword">return</span> installedModules[moduleId].exports;    &#125;    <span class="hljs-comment">// Create a new module (and put it into the cache)</span>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = (installedModules[moduleId] = &#123;      i: moduleId,      l: <span class="hljs-literal">false</span>,      <span class="hljs-built_in">exports</span>: &#123;&#125;,    &#125;);    <span class="hljs-comment">// Execute the module function</span>    modules[moduleId].call(<span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);    <span class="hljs-comment">// Flag the module as loaded</span>    <span class="hljs-built_in">module</span>.l = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// Return the exports of the module</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;  &#125;  <span class="hljs-comment">// Load entry module and return exports</span>  <span class="hljs-keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="hljs-string">&#x27;./src/index.js&#x27;</span>));&#125;)(&#123;  <span class="hljs-string">&#x27;./src/index.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    <span class="hljs-comment">// &#x27;use strict&#x27;;</span>    <span class="hljs-keyword">var</span> _sync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-string">&#x27;./src/sync.js&#x27;</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;外部文件&#x27;</span>, _sync__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string">&#x27;default&#x27;</span>]);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;simple-webpack&#x27;</span>);  &#125;,  <span class="hljs-string">&#x27;./src/sync.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    <span class="hljs-comment">// &#x27;use strict&#x27;;</span>    <span class="hljs-keyword">const</span> data = <span class="hljs-string">&#x27;test-data&#x27;</span>;    __webpack_exports__[<span class="hljs-string">&#x27;default&#x27;</span>] = data;  &#125;,&#125;);</code></pre><h2 id="基于AST实现webpack打包功能"><a href="#基于AST实现webpack打包功能" class="headerlink" title="基于AST实现webpack打包功能"></a>基于AST实现webpack打包功能</h2><p>项目依赖</p><pre><code class="hljs js"><span class="hljs-comment">//package.json</span>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;    <span class="hljs-string">&quot;@babel/traverse&quot;</span>: <span class="hljs-string">&quot;^7.13.0&quot;</span>,    <span class="hljs-string">&quot;babylon&quot;</span>: <span class="hljs-string">&quot;^6.18.0&quot;</span>,    <span class="hljs-string">&quot;ejs&quot;</span>: <span class="hljs-string">&quot;^3.1.6&quot;</span>,    <span class="hljs-string">&quot;magic-string&quot;</span>: <span class="hljs-string">&quot;^0.25.7&quot;</span>,    <span class="hljs-string">&quot;webpack&quot;</span>: <span class="hljs-string">&quot;^4.26.0&quot;</span>,    <span class="hljs-string">&quot;webpack-cli&quot;</span>: <span class="hljs-string">&quot;^3.3.12&quot;</span>  &#125;</code></pre><ol><li>分析入口文件，读取文件内容。  <pre><code class="hljs js"><span class="hljs-keyword">const</span> entry = <span class="hljs-string">&#x27;./src/index.js&#x27;</span>;<span class="hljs-keyword">const</span> content = fs.readFileSync(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>);</code></pre></li><li>代码转换为ast<pre><code class="hljs js"><span class="hljs-keyword">const</span> ast = babylon.parse(content, &#123;    sourceType: <span class="hljs-string">&#x27;module&#x27;</span>,&#125;);</code></pre></li><li>遍历ast代码,替换<code>import</code> 和 <code>export</code> <pre><code class="hljs js">traverse(ast, &#123;  <span class="hljs-function"><span class="hljs-title">ExportDeclaration</span>(<span class="hljs-params">&#123; node &#125;</span>)</span> &#123;    <span class="hljs-keyword">const</span> &#123; start, end, declaration &#125; = node;    code.overwrite(start, end, <span class="hljs-string">`__webpack_exports__[&quot;default&quot;] = <span class="hljs-subst">$&#123;declaration.name&#125;</span>`</span>);  &#125;,  <span class="hljs-function"><span class="hljs-title">ImportDeclaration</span>(<span class="hljs-params">&#123; node &#125;</span>)</span> &#123;    <span class="hljs-keyword">const</span> &#123; start, end, specifiers, source &#125; = node;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;node&#x27;</span>, node);    <span class="hljs-keyword">const</span> newfile = <span class="hljs-string">&#x27;./src/&#x27;</span> + join(source.value);    code.overwrite(start, end, <span class="hljs-string">`var <span class="hljs-subst">$&#123;specifiers[<span class="hljs-number">0</span>].local.name&#125;</span> = __webpack_require__(&quot;<span class="hljs-subst">$&#123;newfile&#125;</span>&quot;).default`</span>);    array.push(newfile);  &#125;,&#125;);</code></pre></li><li>收集依赖  <pre><code class="hljs js"><span class="hljs-keyword">let</span> depencies = [];<span class="hljs-keyword">const</span> _code = code.toString();depencies.push(&#123;  filename,  _code,&#125;);</code></pre></li><li>通过模板生成bundle.js文件内容,输出到文件.  <pre><code class="hljs js">  <span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">  (function (modules) &#123;</span><span class="hljs-string">    // webpackBootstrap</span><span class="hljs-string">    // The module cache</span><span class="hljs-string">    var installedModules = &#123;&#125;;</span><span class="hljs-string"></span><span class="hljs-string">    // The require function</span><span class="hljs-string">    function __webpack_require__(moduleId) &#123;</span><span class="hljs-string">      // Check if module is in cache</span><span class="hljs-string">      if (installedModules[moduleId]) &#123;</span><span class="hljs-string">        return installedModules[moduleId].exports;</span><span class="hljs-string">      &#125;</span><span class="hljs-string">      // Create a new module (and put it into the cache)</span><span class="hljs-string">      var module = (installedModules[moduleId] = &#123;</span><span class="hljs-string">        i: moduleId,</span><span class="hljs-string">        l: false,</span><span class="hljs-string">        exports: &#123;&#125;,</span><span class="hljs-string">      &#125;);</span><span class="hljs-string"></span><span class="hljs-string">      // Execute the module function</span><span class="hljs-string">      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="hljs-string"></span><span class="hljs-string">      // Flag the module as loaded</span><span class="hljs-string">      module.l = true;</span><span class="hljs-string"></span><span class="hljs-string">      // Return the exports of the module</span><span class="hljs-string">      return module.exports;</span><span class="hljs-string">    &#125;</span><span class="hljs-string"></span><span class="hljs-string">    // Load entry module and return exports</span><span class="hljs-string">    return __webpack_require__((__webpack_require__.s = &#x27;./src/index.js&#x27;));</span><span class="hljs-string">  &#125;)(&#123;</span><span class="hljs-string">    &lt;% for(var i=0;i&lt;depencies.length;i++)&#123; %&gt;</span><span class="hljs-string">      &quot;&lt;%- depencies[i][&quot;filename&quot;] %&gt;&quot;:(function(module, __webpack_exports__, __webpack_require__)&#123;</span><span class="hljs-string">        &lt;%- depencies[i]._code%&gt;</span><span class="hljs-string">      &#125;),</span><span class="hljs-string">    &lt;% &#125;%&gt;</span><span class="hljs-string">  &#125;);</span><span class="hljs-string">`</span>;</code></pre>源代码查看请点击<a href="https://github.com/kelh93/simple-webpack">这里</a>，欢迎star，谢谢。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack4 前端工程化 webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从dist分析webpack4与webpack5</title>
    <link href="/2021/02/19/webpack4vswebpack5/"/>
    <url>/2021/02/19/webpack4vswebpack5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/kelh93/webpack4VSwebpack5">源代码传送门</a>  </p><p>webpack5其实很早就更新了，现在<a href="https://webpack.js.org/">webpack官网</a>已经<code>V5.22.0</code>。<br>今天主要是要对比下webpack4打包出来的结果和webpack5有什么差别，以<code>--mode deveplopment</code>为例。<br>从webpack4开始，其实就不需要<code>webpack.config.js</code>也可以进行打包。它会自动从<code>src</code>目录找到<code>index.js</code><br>作为入口文件。  </p><p>先写一个简单的index.js</p><ul><li>webpack4<pre><code class="hljs js"><span class="hljs-comment">// ck-webpack/webpack4/src/index.js</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack4&#x27;</span>);</code></pre></li><li>webpack5<pre><code class="hljs js"><span class="hljs-comment">// ck-webpack/webpack5/src/index.js</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack5&#x27;</span>);</code></pre>查看产生的dist</li></ul><p><strong>webpack4/dist</strong></p><pre><code class="hljs js">  <span class="hljs-comment">// ck-webpack/webpack4/dist/main.js</span>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">modules</span>) </span>&#123;  <span class="hljs-comment">// 模块缓存</span>  <span class="hljs-keyword">var</span> installedModules = &#123;&#125;;  <span class="hljs-comment">// The require function</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>&#123;    <span class="hljs-comment">// 检查模块是否被缓存，如果缓存过则直接返回该模块的exports</span>    <span class="hljs-keyword">if</span> (installedModules[moduleId]) &#123;      <span class="hljs-keyword">return</span> installedModules[moduleId].exports;    &#125;    <span class="hljs-comment">// 如果没有被缓存则创建一个模块对象，并将该对象加入到缓存中。</span>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = (installedModules[moduleId] = &#123;      i: moduleId,      l: <span class="hljs-literal">false</span>,      <span class="hljs-built_in">exports</span>: &#123;&#125;,    &#125;);    <span class="hljs-comment">// 执行module中的function</span>    modules[moduleId].call(<span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);    <span class="hljs-comment">// 模块是否被加载</span>    <span class="hljs-built_in">module</span>.l = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 返回module的exports</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;  &#125;  <span class="hljs-comment">// expose the modules object (__webpack_modules__)</span>  __webpack_require__.m = modules;  <span class="hljs-comment">// expose the module cache</span>  __webpack_require__.c = installedModules;  <span class="hljs-comment">// define getter function for harmony exports</span>  __webpack_require__.d = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">exports</span>, name, getter</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!__webpack_require__.o(<span class="hljs-built_in">exports</span>, name)) &#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, name, &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">get</span>: getter &#125;);    &#125;  &#125;;  <span class="hljs-comment">// define __esModule on exports</span>  __webpack_require__.r = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">exports</span></span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.toStringTag) &#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-built_in">Symbol</span>.toStringTag, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Module&#x27;</span> &#125;);    &#125;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&#x27;__esModule&#x27;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> &#125;);  &#125;;  <span class="hljs-comment">// create a fake namespace object</span>  <span class="hljs-comment">// mode &amp; 1: value is a module id, require it</span>  <span class="hljs-comment">// mode &amp; 2: merge all properties of value into the ns</span>  <span class="hljs-comment">// mode &amp; 4: return value when already ns object</span>  <span class="hljs-comment">// mode &amp; 8|1: behave like require</span>  __webpack_require__.t = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, mode</span>) </span>&#123;    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">1</span>) value = __webpack_require__(value);    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> value;    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class="hljs-keyword">return</span> value;    <span class="hljs-keyword">var</span> ns = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);    __webpack_require__.r(ns);    <span class="hljs-built_in">Object</span>.defineProperty(ns, <span class="hljs-string">&#x27;default&#x27;</span>, &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: value &#125;);    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value != <span class="hljs-string">&#x27;string&#x27;</span>)      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> value)        __webpack_require__.d(          ns,          key,          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>&#123;            <span class="hljs-keyword">return</span> value[key];          &#125;.bind(<span class="hljs-literal">null</span>, key)        );    <span class="hljs-keyword">return</span> ns;  &#125;;  <span class="hljs-comment">// getDefaultExport function for compatibility with non-harmony modules</span>  __webpack_require__.n = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span></span>) </span>&#123;    <span class="hljs-keyword">var</span> getter =      <span class="hljs-built_in">module</span> &amp;&amp; <span class="hljs-built_in">module</span>.__esModule        ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDefault</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>[<span class="hljs-string">&#x27;default&#x27;</span>];          &#125;        : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getModuleExports</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>;          &#125;;    __webpack_require__.d(getter, <span class="hljs-string">&#x27;a&#x27;</span>, getter);    <span class="hljs-keyword">return</span> getter;  &#125;;  <span class="hljs-comment">// Object.prototype.hasOwnProperty.call</span>  __webpack_require__.o = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object, property</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(object, property);  &#125;;  <span class="hljs-comment">// __webpack_public_path__</span>  __webpack_require__.p = <span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-comment">// Load entry module and return exports</span>  <span class="hljs-keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="hljs-string">&#x27;./src/index.js&#x27;</span>));&#125;)(&#123;  <span class="hljs-string">&#x27;./src/index.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack4&#x27;</span>);  &#125;,&#125;);</code></pre><p><strong>webpack5/dist</strong></p><pre><code class="hljs js"><span class="hljs-comment">//ck-webpack/webpack5/dist/main.js</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// webpackBootstrap</span>  <span class="hljs-keyword">var</span> __webpack_modules__ = &#123;    <span class="hljs-string">&#x27;./src/index.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack5&#x27;</span>);    &#125;,  &#125;;  <span class="hljs-keyword">var</span> __webpack_exports__ = &#123;&#125;;  __webpack_modules__[<span class="hljs-string">&#x27;./src/index.js&#x27;</span>]();&#125;)();</code></pre><h3 id="分析dist"><a href="#分析dist" class="headerlink" title="分析dist"></a>分析dist</h3><ul><li>webpack4<br>生成的main.js是一个闭包<br>参数： 模块对象，以模块路径作为key，也就是moduleId，模块的内容被包裹在一个function中<br>返回值： 返回<code>__webpack_require__</code>函数的<code>module.exports</code>。</li></ul><p><strong>__webpack_require__</strong><br>参数: <code>moduleId</code><br>返回值: module.exports  </p><ul><li>webpack5<br>webpack5生成的main.js也是一个闭包，但是隐藏了很多细节，也没有了之前的一些静态属性。因为入口文件非常简单。  </li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ol><li>webpack5生成的main.js的文件，比webpack4更加简洁，因为浏览器已经大部分支持了ES6，所以省去了很多之前polyfill的代码。  </li><li>webpack5使用了ES6的箭头函数，也不需要在<code>modules[moduleId].call</code>去固定this指向了。<blockquote><p>ps：上面代码段的main.js删除了一些无用的注释，把eval中的代码放开了。<br>上面是从一个最简单的入口文件分析的结果。如果入口文件复杂一些呢，引入其他文件。</p></blockquote><h2 id="入口文件引入其他文件"><a href="#入口文件引入其他文件" class="headerlink" title="入口文件引入其他文件"></a>入口文件引入其他文件</h2></li></ol><ul><li>webpack4<br>在入口文件引入了<code>add.js</code>和<code>tool.js</code><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">import</span> add <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./add&#x27;</span>;<span class="hljs-keyword">import</span> upperCase <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./tool&#x27;</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack4&#x27;</span>);<span class="hljs-keyword">var</span> c = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1+2等于&#x27;</span>, c);<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;apple&#x27;</span>;<span class="hljs-keyword">var</span> d = upperCase(str);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;apple转大写&#x27;</span>, d);<span class="hljs-comment">// add.js</span><span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-keyword">return</span> a + b;&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> add;<span class="hljs-comment">// tool.js</span><span class="hljs-keyword">const</span> upperCase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.toUpperCase();&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> upperCase;</code></pre></li><li>webpack5<br>代码和webpack4一致，不再赘述。来看看生成的dist。    </li></ul><p><strong>webpack4/dist</strong></p><pre><code class="hljs js">  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>)</span>&#123;    <span class="hljs-comment">/* ... */</span>    <span class="hljs-comment">// 首先执行入口文件</span>    <span class="hljs-keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="hljs-string">&#x27;./src/index.js&#x27;</span>));  &#125;)(&#123;  <span class="hljs-string">&#x27;./src/add.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    __webpack_require__.r(__webpack_exports__);    <span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;      <span class="hljs-keyword">return</span> a + b;    &#125;;    __webpack_exports__[<span class="hljs-string">&#x27;default&#x27;</span>] = add;  &#125;,  <span class="hljs-string">&#x27;./src/index.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    __webpack_require__.r(__webpack_exports__);    <span class="hljs-keyword">var</span> _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-string">&#x27;./src/add.js&#x27;</span>);    <span class="hljs-keyword">var</span> _tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(<span class="hljs-string">&#x27;./src/tool.js&#x27;</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack4&#x27;</span>);    <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">Object</span>(_add__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string">&#x27;default&#x27;</span>])(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1+2等于&#x27;</span>, c);    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;apple&#x27;</span>;    <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Object</span>(_tool__WEBPACK_IMPORTED_MODULE_1__[<span class="hljs-string">&#x27;default&#x27;</span>])(str);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;apple转大写&#x27;</span>, d);  &#125;,  <span class="hljs-string">&#x27;./src/tool.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    __webpack_require__.r(__webpack_exports__);    <span class="hljs-keyword">const</span> upperCase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;      <span class="hljs-keyword">return</span> str.toUpperCase();    &#125;;    __webpack_exports__[<span class="hljs-string">&#x27;default&#x27;</span>] = upperCase;  &#125;,&#125;)</code></pre><p>webpack4将每个模块都放入到<code>modules</code>对象中，<code>index.js</code>通过<code>__webpack_require__</code>引入依赖的模块。<br>在<code>add.js</code>和<code>tools.js</code>的function中，使用<code>__webpack_exports__</code>对外暴露接口。<br><strong>webpack5/dist</strong></p><pre><code class="hljs js">(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-keyword">var</span> __webpack_modules__ = &#123;    <span class="hljs-string">&#x27;./src/add.js&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;      __webpack_require__.r(__webpack_exports__);      __webpack_require__.d(__webpack_exports__, &#123;        <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> __WEBPACK_DEFAULT_EXPORT__,      &#125;);      <span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;        <span class="hljs-keyword">return</span> a + b;      &#125;;      <span class="hljs-keyword">const</span> __WEBPACK_DEFAULT_EXPORT__ = add;    &#125;,    <span class="hljs-string">&#x27;./src/index.js&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;      __webpack_require__.r(__webpack_exports__);      <span class="hljs-keyword">var</span> _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-string">&#x27;./src/add.js&#x27;</span>);      <span class="hljs-keyword">var</span> _tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(<span class="hljs-string">&#x27;./src/tool.js&#x27;</span>);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack5&#x27;</span>);      <span class="hljs-keyword">var</span> c = (<span class="hljs-number">0</span>, _add__WEBPACK_IMPORTED_MODULE_0__.default)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1+2等于&#x27;</span>, c);      <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;apple&#x27;</span>;      <span class="hljs-keyword">var</span> d = (<span class="hljs-number">0</span>, _tool__WEBPACK_IMPORTED_MODULE_1__.default)(str);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;apple转大写&#x27;</span>, d);    &#125;,    <span class="hljs-string">&#x27;./src/tool.js&#x27;</span>: <span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;      __webpack_require__.r(__webpack_exports__);      __webpack_require__.d(__webpack_exports__, &#123; <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> __WEBPACK_DEFAULT_EXPORT__ &#125;);      <span class="hljs-keyword">const</span> upperCase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;        <span class="hljs-keyword">return</span> str.toUpperCase();      &#125;;      <span class="hljs-keyword">const</span> __WEBPACK_DEFAULT_EXPORT__ = upperCase;    &#125;,  &#125;;  <span class="hljs-comment">/* ... */</span>    (<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// define getter functions for harmony exports</span>      __webpack_require__.d = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">exports</span>, definition</span>) =&gt;</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> definition) &#123;          <span class="hljs-keyword">if</span> (__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(<span class="hljs-built_in">exports</span>, key)) &#123;            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, key, &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">get</span>: definition[key] &#125;);          &#125;        &#125;      &#125;;    &#125;)();    <span class="hljs-comment">/* webpack/runtime/hasOwnProperty shorthand */</span>    (<span class="hljs-function">() =&gt;</span> &#123;      __webpack_require__.o = <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);    &#125;)();  <span class="hljs-comment">/* webpack/runtime/make namespace object */</span>  (<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// define __esModule on exports</span>    __webpack_require__.r = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">exports</span></span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.toStringTag) &#123;        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-built_in">Symbol</span>.toStringTag, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Module&#x27;</span> &#125;);      &#125;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&#x27;__esModule&#x27;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> &#125;);    &#125;;  &#125;);  <span class="hljs-keyword">var</span> __webpack_exports__ = __webpack_require__(<span class="hljs-string">&#x27;./src/index.js&#x27;</span>);&#125;)()</code></pre><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><ol><li>webpack5将webpack4中的modules参数放到了闭包函数的内部使用变量<code>__webpack_modules__</code>保存。</li><li>webpack5将<code>__webpack_require__</code>的静态属性方法都使用箭头函数包裹。</li></ol><h3 id="webpack4与webpack5异步加载js"><a href="#webpack4与webpack5异步加载js" class="headerlink" title="webpack4与webpack5异步加载js"></a>webpack4与webpack5异步加载js</h3><p>webpack5解决了webpack4打包异步js，chunkId被串改的问题。我们可以做一个实验。</p><ul><li>webpack4<pre><code class="hljs js">  <span class="hljs-comment">// index.js</span>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./sync&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    onsole.log(data);  &#125;);  <span class="hljs-comment">// sync.js</span>  <span class="hljs-keyword">const</span> data = <span class="hljs-string">&#x27;同步js&#x27;</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> data;&#125;);</code></pre>执行yarn dev，生成dist文件,生成了0.js，就是sync.js打包后的文件。  </li></ul><p><img src="/images/webpack4vswebpack5/1.png" alt="webpack4 打包结果">  </p><p><img src="/images/webpack4vswebpack5/2.png" alt="sync.js打包结果"><br>如果再增加一个异步js。  </p><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./sync&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  onsole.log(data);&#125;);<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./async&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;_&#x27;</span>, _);&#125;);<span class="hljs-comment">// sync.js</span><span class="hljs-keyword">const</span> data = <span class="hljs-string">&#x27;同步js&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> data;<span class="hljs-comment">// async.js</span><span class="hljs-keyword">const</span> data = <span class="hljs-string">&#x27;异步js&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> data;</code></pre><p>再次打包执行<code>yarn dev</code>  </p><p><img src="/images/webpack4vswebpack5/3.png" alt="webpack4增加async.js后的打包结果">  </p><p><img src="/images/webpack4vswebpack5/4.png" alt="原先的chunkId被async覆盖"><br>之前的0.js的内容被async.js的内容覆盖了。webpack4也给出了解决方法，可以使用魔法注释。<br>在引入异步js的时候加上<code>/* webpackChunkName: &#39;sync&#39; */</code>就可以固定异步js的文件名。  </p><pre><code class="hljs js">  <span class="hljs-comment">// index.js</span><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &#x27;sync&#x27; */</span> <span class="hljs-string">&#x27;./sync&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  onsole.log(data);&#125;);<span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &#x27;async&#x27; */</span><span class="hljs-string">&#x27;./async&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;_&#x27;</span>, _);&#125;);</code></pre><p>更改之后打包出来的文件名就会固定，不会被覆盖。<br><img src="/images/webpack4vswebpack5/5.png" alt="webpack4新增魔法注释">  </p><p><strong>但是webpack5不存在这个问题</strong>  </p><p><img src="/images/webpack4vswebpack5/6.png" alt="webpack5异步加载打包结果"><br>webpack5在<code>development</code>环境下，打包出来的异步js文件名使用文件路径进行拼接，防止重名。在<code>production</code>环境下，chunk id是<code>deterministic</code>。</p><blockquote><p><a href="https://webpack.js.org/configuration/optimization/#optimizationchunkids">摘自webpack官网</a><br><code>optimization.chunkIds</code><br><code>boolean = false string: &#39;natural&#39; | &#39;named&#39; | &#39;size&#39; | &#39;total-size&#39; | &#39;deterministic&#39;</code><br>告诉webpack生成chunk id的逻辑。设置<code>false</code>，则通过自定义插件进行设置。</p><ul><li>另外如果是开发环境那么<code>optimization.chunkIds</code>设置为’named’,如果是生产环境则设置为<code>deterministic</code>;  </li><li>如果以上都没有，则默认设置为<code>natural</code>(自然数)<pre><code class="hljs js">&gt;<span class="hljs-built_in">module</span>.exports = &#123; <span class="hljs-comment">//...</span> optimization: &#123;   chunkIds: <span class="hljs-string">&#x27;deterministic&#x27;</span> &#125;&#125;</code></pre></li></ul></blockquote><h2 id="webpack异步加载原理"><a href="#webpack异步加载原理" class="headerlink" title="webpack异步加载原理"></a>webpack异步加载原理</h2><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">modules</span>) </span>&#123;  <span class="hljs-comment">// webpackBootstrap</span>  <span class="hljs-comment">// install a JSONP callback for chunk loading</span>  <span class="hljs-comment">// webpack异步加载js的回调,将加载完成的js打上已安装的flag==&gt;installedChunks[chunkId] = 0;</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">webpackJsonpCallback</span>(<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-keyword">var</span> chunkIds = data[<span class="hljs-number">0</span>];    <span class="hljs-keyword">var</span> moreModules = data[<span class="hljs-number">1</span>];    <span class="hljs-comment">// add &quot;moreModules&quot; to the modules object,</span>    <span class="hljs-comment">// then flag all &quot;chunkIds&quot; as loaded and fire callback</span>    <span class="hljs-keyword">var</span> moduleId,      chunkId,      i = <span class="hljs-number">0</span>,      resolves = [];    <span class="hljs-keyword">for</span> (; i &lt; chunkIds.length; i++) &#123;      chunkId = chunkIds[i];      <span class="hljs-comment">// if(installedChunks.chunkId &amp;&amp; installedChunks[chunkId])</span>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;        <span class="hljs-comment">// installedChunks[chunkId][0]就是加载成功的resolve方法.</span>        resolves.push(installedChunks[chunkId][<span class="hljs-number">0</span>]);      &#125;      <span class="hljs-comment">// 异步加载完成后将chunkId打上已安装的flag</span>      installedChunks[chunkId] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span> (moduleId <span class="hljs-keyword">in</span> moreModules) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;        modules[moduleId] = moreModules[moduleId];      &#125;    &#125;    <span class="hljs-keyword">if</span> (parentJsonpFunction) parentJsonpFunction(data);    <span class="hljs-comment">// 执行promise.resolve回调函数</span>    <span class="hljs-keyword">while</span> (resolves.length) &#123;      resolves.shift()();    &#125;  &#125;  <span class="hljs-comment">// The module cache</span>  <span class="hljs-keyword">var</span> installedModules = &#123;&#125;;  <span class="hljs-comment">// object to store loaded and loading chunks</span>  <span class="hljs-comment">// undefined = chunk not loaded, null = chunk preloaded/prefetched</span>  <span class="hljs-comment">// Promise = chunk loading, 0 = chunk loaded</span>  <span class="hljs-comment">// 哨兵变量。记录加载过的chunk</span>  <span class="hljs-keyword">var</span> installedChunks = &#123;    main: <span class="hljs-number">0</span>,  &#125;;  <span class="hljs-comment">// script path function</span>  <span class="hljs-comment">// 拼接异步script路径</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonpScriptSrc</span>(<span class="hljs-params">chunkId</span>) </span>&#123;    <span class="hljs-keyword">return</span> __webpack_require__.p + <span class="hljs-string">&#x27;&#x27;</span> + (&#123; <span class="hljs-attr">async</span>: <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-attr">sync</span>: <span class="hljs-string">&#x27;sync&#x27;</span> &#125;[chunkId] || chunkId) + <span class="hljs-string">&#x27;.js&#x27;</span>;  &#125;  <span class="hljs-comment">// The require function</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>&#123;    <span class="hljs-comment">// Check if module is in cache</span>    <span class="hljs-keyword">if</span> (installedModules[moduleId]) &#123;      <span class="hljs-keyword">return</span> installedModules[moduleId].exports;    &#125;    <span class="hljs-comment">// Create a new module (and put it into the cache)</span>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = (installedModules[moduleId] = &#123;      i: moduleId,      l: <span class="hljs-literal">false</span>,      <span class="hljs-built_in">exports</span>: &#123;&#125;,    &#125;);    <span class="hljs-comment">// Execute the module function</span>    modules[moduleId].call(<span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);    <span class="hljs-comment">// Flag the module as loaded</span>    <span class="hljs-built_in">module</span>.l = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// Return the exports of the module</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;  &#125;  <span class="hljs-comment">// This file contains only the entry chunk.</span>  <span class="hljs-comment">// The chunk loading function for additional chunks</span>  <span class="hljs-comment">// 通过主入口进行异步的启动的过程</span>  __webpack_require__.e = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requireEnsure</span>(<span class="hljs-params">chunkId</span>) </span>&#123;    <span class="hljs-keyword">var</span> promises = [];    <span class="hljs-comment">// JSONP chunk loading for javascript</span>    <span class="hljs-keyword">var</span> installedChunkData = installedChunks[chunkId];    <span class="hljs-comment">// 0 代表以及安装了</span>    <span class="hljs-keyword">if</span> (installedChunkData !== <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// 存在则直接将模块的函数放到promise</span>      <span class="hljs-keyword">if</span> (installedChunkData) &#123;        <span class="hljs-comment">// installedChunkData[2] ==&gt; installedChunks[chunkId][2] ==&gt; module.exports</span>        <span class="hljs-comment">// 因为installedChunks[chunkId] = [resolve, reject];// 0是resolve，1是reject</span>        <span class="hljs-comment">// installedChunkData[2] = promise</span>        promises.push(installedChunkData[<span class="hljs-number">2</span>]);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// setup Promise in chunk cache</span>        <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;          <span class="hljs-comment">// 异步加载promise</span>          <span class="hljs-comment">// installedChunks[chunkId] = [resolve, reject];</span>          <span class="hljs-comment">// installedChunkData = [resolve, reject];</span>          installedChunkData = installedChunks[chunkId] = [resolve, reject];        &#125;);        promises.push((installedChunkData[<span class="hljs-number">2</span>] = promise));        <span class="hljs-comment">// 开始模块加载</span>        <span class="hljs-comment">// 通过 DOM 操作，往 HTML head 中插入一个 script标签去异步加载 Chunk 对应的 JavaScript文件</span>        <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);        <span class="hljs-keyword">var</span> onScriptComplete;        script.charset = <span class="hljs-string">&#x27;utf-8&#x27;</span>;        script.timeout = <span class="hljs-number">120</span>;        <span class="hljs-keyword">if</span> (__webpack_require__.nc) &#123;          script.setAttribute(<span class="hljs-string">&#x27;nonce&#x27;</span>, __webpack_require__.nc);        &#125;        script.src = jsonpScriptSrc(chunkId);        <span class="hljs-comment">// create error before stack unwound to get useful stacktrace later</span>        <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();        <span class="hljs-comment">// 在 script加载和执行完成时回调</span>        onScriptComplete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;          <span class="hljs-comment">// avoid mem leaks in IE.</span>          script.onerror = script.onload = <span class="hljs-literal">null</span>;          <span class="hljs-built_in">clearTimeout</span>(timeout);          <span class="hljs-comment">// 去检查 chunkId 对应的 Chunk 是否安装成功，安装成功时才会存在于 installedChunks 中</span>          <span class="hljs-keyword">var</span> chunk = installedChunks[chunkId];          <span class="hljs-comment">// onload之后，chunk != 0，表示没有正常加载完成。</span>          <span class="hljs-keyword">if</span> (chunk !== <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 加载失败</span>            <span class="hljs-keyword">if</span> (chunk) &#123;              <span class="hljs-keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="hljs-string">&#x27;load&#x27;</span> ? <span class="hljs-string">&#x27;missing&#x27;</span> : event.type);              <span class="hljs-keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;              error.message = <span class="hljs-string">&#x27;Loading chunk &#x27;</span> + chunkId + <span class="hljs-string">&#x27; failed.\n(&#x27;</span> + errorType + <span class="hljs-string">&#x27;: &#x27;</span> + realSrc + <span class="hljs-string">&#x27;)&#x27;</span>;              error.name = <span class="hljs-string">&#x27;ChunkLoadError&#x27;</span>;              error.type = errorType;              error.request = realSrc;              <span class="hljs-comment">// 执行reject，返回error</span>              chunk[<span class="hljs-number">1</span>](error);            &#125;            <span class="hljs-comment">// 未找到。将chunkId赋值为undefined</span>            installedChunks[chunkId] = <span class="hljs-literal">undefined</span>;          &#125;        &#125;;        <span class="hljs-keyword">var</span> timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;          onScriptComplete(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-attr">target</span>: script &#125;);        &#125;, <span class="hljs-number">120000</span>);        script.onerror = script.onload = onScriptComplete;        <span class="hljs-built_in">document</span>.head.appendChild(script);      &#125;    &#125;    <span class="hljs-comment">// Promise.all 返回一个数组</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(promises);  &#125;;  <span class="hljs-comment">// expose the modules object (__webpack_modules__)</span>  __webpack_require__.m = modules;  <span class="hljs-comment">// expose the module cache</span>  __webpack_require__.c = installedModules;  <span class="hljs-comment">// define getter function for harmony exports</span>  __webpack_require__.d = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">exports</span>, name, getter</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!__webpack_require__.o(<span class="hljs-built_in">exports</span>, name)) &#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, name, &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">get</span>: getter &#125;);    &#125;  &#125;;  <span class="hljs-comment">// define __esModule on exports</span>  __webpack_require__.r = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">exports</span></span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.toStringTag) &#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-built_in">Symbol</span>.toStringTag, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Module&#x27;</span> &#125;);    &#125;    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&#x27;__esModule&#x27;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> &#125;);  &#125;;  <span class="hljs-comment">// create a fake namespace object</span>  <span class="hljs-comment">// mode &amp; 1: value is a module id, require it</span>  <span class="hljs-comment">// mode &amp; 2: merge all properties of value into the ns</span>  <span class="hljs-comment">// mode &amp; 4: return value when already ns object</span>  <span class="hljs-comment">// mode &amp; 8|1: behave like require</span>  __webpack_require__.t = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, mode</span>) </span>&#123;    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">1</span>) value = __webpack_require__(value);    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> value;    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class="hljs-keyword">return</span> value;    <span class="hljs-keyword">var</span> ns = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);    __webpack_require__.r(ns);    <span class="hljs-built_in">Object</span>.defineProperty(ns, <span class="hljs-string">&#x27;default&#x27;</span>, &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: value &#125;);    <span class="hljs-keyword">if</span> (mode &amp; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value != <span class="hljs-string">&#x27;string&#x27;</span>)      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> value)        __webpack_require__.d(          ns,          key,          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>&#123;            <span class="hljs-keyword">return</span> value[key];          &#125;.bind(<span class="hljs-literal">null</span>, key)        );    <span class="hljs-keyword">return</span> ns;  &#125;;  <span class="hljs-comment">// getDefaultExport function for compatibility with non-harmony modules</span>  __webpack_require__.n = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span></span>) </span>&#123;    <span class="hljs-keyword">var</span> getter =      <span class="hljs-built_in">module</span> &amp;&amp; <span class="hljs-built_in">module</span>.__esModule        ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDefault</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>[<span class="hljs-string">&#x27;default&#x27;</span>];          &#125;        : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getModuleExports</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>;          &#125;;    __webpack_require__.d(getter, <span class="hljs-string">&#x27;a&#x27;</span>, getter);    <span class="hljs-keyword">return</span> getter;  &#125;;  <span class="hljs-comment">// Object.prototype.hasOwnProperty.call</span>  __webpack_require__.o = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object, property</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(object, property);  &#125;;  <span class="hljs-comment">// __webpack_public_path__</span>  __webpack_require__.p = <span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-comment">// on error function for async loading</span>  __webpack_require__.oe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-built_in">console</span>.error(err);    <span class="hljs-keyword">throw</span> err;  &#125;;  <span class="hljs-comment">// 执行webpackJsonp的回调</span>  <span class="hljs-keyword">var</span> jsonpArray = (<span class="hljs-built_in">window</span>[<span class="hljs-string">&#x27;webpackJsonp&#x27;</span>] = <span class="hljs-built_in">window</span>[<span class="hljs-string">&#x27;webpackJsonp&#x27;</span>] || []);  <span class="hljs-keyword">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);  jsonpArray.push = webpackJsonpCallback;  jsonpArray = jsonpArray.slice();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);  <span class="hljs-keyword">var</span> parentJsonpFunction = oldJsonpFunction;  <span class="hljs-comment">// Load entry module and return exports</span>  <span class="hljs-keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="hljs-string">&#x27;./src/index.js&#x27;</span>));&#125;)(&#123;  <span class="hljs-string">&#x27;./src/add.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    __webpack_require__.r(__webpack_exports__);    <span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;      <span class="hljs-keyword">return</span> a + b;    &#125;;    __webpack_exports__[<span class="hljs-string">&#x27;default&#x27;</span>] = add;    <span class="hljs-comment">// sourceMap原理</span>    <span class="hljs-comment">//# sourceURL=webpack:///./src/add.js?&#x27;</span>  &#125;,  <span class="hljs-string">&#x27;./src/index.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    __webpack_require__.r(__webpack_exports__);    <span class="hljs-keyword">var</span> _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-string">&#x27;./src/add.js&#x27;</span>);    <span class="hljs-keyword">var</span> _tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(<span class="hljs-string">&#x27;./src/tool.js&#x27;</span>);    __webpack_require__      .e(<span class="hljs-string">&#x27;sync&#x27;</span>)      .then(__webpack_require__.bind(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;./src/sync.js&#x27;</span>))      .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(data);      &#125;);    __webpack_require__      .e(<span class="hljs-string">&#x27;async&#x27;</span>)      .then(__webpack_require__.bind(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;./src/async.js&#x27;</span>))      .then(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;_&#x27;</span>, _);      &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ck-webpack4&#x27;</span>);    <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">Object</span>(_add__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string">&#x27;default&#x27;</span>])(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1+2等于&#x27;</span>, c);    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;apple&#x27;</span>;    <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Object</span>(_tool__WEBPACK_IMPORTED_MODULE_1__[<span class="hljs-string">&#x27;default&#x27;</span>])(str);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;apple转大写&#x27;</span>, d);  &#125;,  <span class="hljs-string">&#x27;./src/tool.js&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;    __webpack_require__.r(__webpack_exports__);    <span class="hljs-keyword">const</span> upperCase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;      <span class="hljs-keyword">return</span> str.toUpperCase();    &#125;;    __webpack_exports__[<span class="hljs-string">&#x27;default&#x27;</span>] = upperCase;  &#125;,&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现函数重载</title>
    <link href="/2021/01/15/function-overloading/"/>
    <url>/2021/01/15/function-overloading/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是函数重载？"><a href="#什么是函数重载？" class="headerlink" title="什么是函数重载？"></a>什么是函数重载？</h2><p>  函数的重载指的是一组具有相同名称的函数，不同参数列表的方法。</p><blockquote><p>javascript本身是不支持函数重载的，同名函数的后一个会覆盖前一个。<br>考虑以下例子：</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">return</span> num + <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">var</span> result = sum(<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出3；因为sum的赋值被后一个覆盖了。</span></code></pre><p>那么如何模拟实现函数的重载呢？</p><h2 id="模拟函数重载"><a href="#模拟函数重载" class="headerlink" title="模拟函数重载"></a>模拟函数重载</h2><ol><li>JavaScript函数有一个arguments属性来表示函数形参的个数。我们可以通过判断arguments的长度去实现。<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:       <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:      <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:      <span class="hljs-comment">// ...</span>      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;&#125;</code></pre>显然这样的代码难以维护，我们可以试试另外一种方式。参照</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图和图算法</title>
    <link href="/2020/12/24/Graph/"/>
    <url>/2020/12/24/Graph/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ol><li><p>图的定义<br><code>图</code>由<code>边</code>的集合及<code>顶点</code>的集合组成。<code>顶点</code>也有权重，也称为<code>成本</code>。<br>如果一个图的顶点是有序的，则可以称之为<code>有向图</code>。在对有向图的顶点对排序后，便可以在两个顶点之间绘制一个箭头。有向图表明了顶点的流向。如果图是无序的，则称之为<code>无序图</code>或<code>无向图</code>。</p></li><li><p><code>图</code>中的一系列顶点构成<code>路径</code>，路径中的所有顶点都由边连接。</p></li><li><p><code>路径的长度</code>用路径中<code>第一个顶点</code>到<code>最后一个顶点</code>之间的<code>边的数量</code>表示。</p></li><li><p>由<code>指向自身的顶点</code>组成的路径称为<code>环</code>，环的长度为0.</p></li></ol><h2 id="图：由顶点和边构建"><a href="#图：由顶点和边构建" class="headerlink" title="图：由顶点和边构建"></a>图：由顶点和边构建</h2><h3 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h3><p>创建<code>Vertex</code>类保存顶点和边。这个类的作用与<a href="http://www.kelinghong.com/2020/12/11/linkedlist/">链表</a>和<a href="http://www.kelinghong.com/2020/12/20/BST/">二叉查找树</a>的Node类一样。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vertex</span>(<span class="hljs-params">label, wasVisited</span>)</span>&#123;  <span class="hljs-built_in">this</span>.label = label; <span class="hljs-comment">// 顶点</span>  <span class="hljs-built_in">this</span>.wasVisited = wasVisited; <span class="hljs-comment">// 顶点是否被访问过(也就是是否被遍历过)</span>&#125;</code></pre><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>我们将表示图的<code>边</code>的方法称为<code>邻接表</code>或者<code>邻接表数组</code>。这种方法将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。<br>另一种表示图边的方法被称为<code>邻接矩阵</code>。它是一个<code>二维数组</code>，其中的元素表示两个顶点之间是否有一条边。  </p><h2 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Graph</span>(<span class="hljs-params">v</span>)</span>&#123;  <span class="hljs-built_in">this</span>.vertices = <span class="hljs-number">0</span>;  <span class="hljs-built_in">this</span>.edges = <span class="hljs-number">0</span>;  <span class="hljs-built_in">this</span>.adj = [];  <span class="hljs-comment">// 构建二维数组this.adj,保存所有相邻顶点。</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">this</span>.vertices.length;i++)&#123;    <span class="hljs-built_in">this</span>.adj[i] = [];    <span class="hljs-built_in">this</span>.adj[i].push(<span class="hljs-string">&#x27;&#x27;</span>);  &#125;  <span class="hljs-built_in">this</span>.addEdge = addEdge;  <span class="hljs-built_in">this</span>.toString = toString.&#125;<span class="hljs-comment">// 调用函数传入顶点A和B，函数先查找顶点A的邻接表，将顶点B添加到列表中。</span><span class="hljs-comment">// 然后再查找B的邻接表，将顶点A加入列表，最后这个函数的边数量加1。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params">v, w</span>)</span>&#123;  <span class="hljs-built_in">this</span>.adj[v].push(w);  <span class="hljs-built_in">this</span>.adj[w].push(v);  <span class="hljs-built_in">this</span>.edges++;&#125;<span class="hljs-comment">// 相当于遍历图的`边`和`列`</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showGraph</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.vertices; i++)&#123;    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.vertices; ++j)&#123;      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.adj[i][j] != <span class="hljs-literal">undefined</span>)&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.adj[i][j] + <span class="hljs-string">&#x27;&#x27;</span>);      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="搜索图"><a href="#搜索图" class="headerlink" title="搜索图"></a>搜索图</h2><h3 id="1-DFS-深度优先搜索"><a href="#1-DFS-深度优先搜索" class="headerlink" title="1. DFS (深度优先搜索)"></a>1. DFS (深度优先搜索)</h3><p><code>深度优先搜索</code>包括从一条路径的<code>起始顶点开始追溯，直到到达最后一个顶点</code>，然后回溯，继续追溯下一条路径，直到到达最后的顶点。如此往复，直到没有路径为止。这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。<br>深度优先搜索的算法比较简单：访问一个没有访问过的顶点，将它标记为以访问，再递归的去访问在初始顶点的邻接表中其他没有访问过的顶点。</p><blockquote><p>总结：DFS搜索方式是<code>纵向遍历</code>。</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Graph</span>(<span class="hljs-params">v</span>)</span>&#123;  <span class="hljs-built_in">this</span>.vertices = v;  <span class="hljs-built_in">this</span>.edges = <span class="hljs-number">0</span>;  <span class="hljs-built_in">this</span>.adj = []; <span class="hljs-comment">// 创建图的二维数组</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.vertices;i++)&#123;    <span class="hljs-built_in">this</span>.adj[i] = [];    <span class="hljs-built_in">this</span>.adj[i].push(<span class="hljs-string">&#x27;&#x27;</span>);  &#125;  <span class="hljs-built_in">this</span>.addEdge = addEdge;  <span class="hljs-built_in">this</span>.showGraph = showGraph;  <span class="hljs-built_in">this</span>.dfs = dfs;  <span class="hljs-built_in">this</span>.marked = [];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">this</span>.vertices; i++)&#123;    <span class="hljs-built_in">this</span>.marked[i] = <span class="hljs-literal">false</span>;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params">v, w</span>) </span>&#123;  <span class="hljs-built_in">this</span>.adj[v].push(w);  <span class="hljs-built_in">this</span>.adj[w].push(v);  <span class="hljs-built_in">this</span>.edges++;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showGraph</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.adj; ++i)&#123;    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;-&gt;&#x27;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">this</span>.adj[i]; ++i)&#123;      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.adj[i][j] != <span class="hljs-literal">undefined</span>)&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.add[i][j] + <span class="hljs-string">&#x27; &#x27;</span>);      &#125;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">v</span>)</span>&#123;  <span class="hljs-built_in">this</span>.marked[v] = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.adj[v] != <span class="hljs-literal">undefined</span>)&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;visited vertex:&#x27;</span> + v);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.adj[v])&#123;      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.marked[w])&#123;        <span class="hljs-built_in">this</span>.dfs(w);      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// 测试dfs</span><span class="hljs-keyword">let</span> g = <span class="hljs-keyword">new</span> Graph(<span class="hljs-number">5</span>); <span class="hljs-comment">// [[],[],[],[],[]]</span><span class="hljs-comment">// this.adj[0].push(1);</span><span class="hljs-comment">// this.adj[1].push(0);</span>g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// [[1],[0],[],[],[]]</span>g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// [[1,2],[0],[0],[],[]]</span>g.addEdge(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// [[1,2],[0,3],[0],[1],[]]</span>g.addEdge(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">// [[1,2],[0,3],[0,4],[1],[2]]</span>g.showGraph(); <span class="hljs-comment">// 1,2 0,3 0,4 1, 2</span>g.dfs(<span class="hljs-number">0</span>); <span class="hljs-comment">// 从this.adj[v], v=0开始遍历</span><span class="hljs-comment">// 输出结果：</span><span class="hljs-comment">// [[1,2],[0,3],[0,4],[1],[2]]</span></code></pre><h3 id="2-BFS-广度优先搜索"><a href="#2-BFS-广度优先搜索" class="headerlink" title="2. BFS (广度优先搜索)"></a>2. BFS (广度优先搜索)</h3><p><code>广度优先搜索</code>从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索在图上是<code>逐层移动</code>的，首先检查最靠近第一个顶点的层，再逐渐<code>向下移动</code>到离起始顶点最远的层。</p><blockquote><p>总结：<code>BFS</code>的搜索方式是<code>横向搜索</code>，就近原则遍历。</p></blockquote><p>广度优先搜索算法使用了<code>抽象的队列</code>而不是数组来对<code>已访问过的顶点进行排序</code>。其算法的工作原理如下：  </p><ol><li>查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中。</li><li>从图中取出下一个顶点v，添加到已访问的顶点列表。</li><li>将所有与v相邻的未访问顶点添加到队列。 </li></ol><pre><code class="hljs js"><span class="hljs-comment">// 广度优先搜索的遍历过程</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-keyword">var</span> queue = [];  <span class="hljs-built_in">this</span>.marked[s] = <span class="hljs-literal">true</span>;  queue.push(s); <span class="hljs-comment">// 添加到队尾</span>  <span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">var</span> v = queue.shift(); <span class="hljs-comment">// 从队首移除</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.adj[v] != <span class="hljs-literal">undefined</span>)&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;已访问过的顶点：&#x27;</span>, v);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.adj[v])&#123;      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.marked[w])&#123;        <span class="hljs-built_in">this</span>.marked[w] = <span class="hljs-literal">true</span>;        queue.push(w);      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// 测试：</span><span class="hljs-keyword">var</span> g = <span class="hljs-keyword">new</span> Graph(<span class="hljs-number">5</span>);g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);g.addEdge(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);g.addEdge(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);g.showGraph();g.bfs(<span class="hljs-number">0</span>);</code></pre><h4 id="广度优先搜索-查找最短路径"><a href="#广度优先搜索-查找最短路径" class="headerlink" title="广度优先搜索-查找最短路径"></a>广度优先搜索-查找最短路径</h4><p>要查找最短路径，需要修改广度优先搜索算法来记录从一个顶点到另一个顶点的路径。这需要对Graph类做一些修改。<br>首先，需要一个数组来保存从一个顶点到下一个顶点的所有边。我们将这个数组命名为 edgeTo。因为从始至终使用的都是广度优先搜索函数，所以每次都会遇到一个没有标记的顶点，除了对它进行标记外，还会从邻接列表中我们正在探索的那个顶点添加一条边到这个顶点。  </p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.edgeTo = edgeTo;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-keyword">var</span> queue = [];  <span class="hljs-built_in">this</span>.marked[s] = <span class="hljs-literal">true</span>;  queue.push(s);  <span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">var</span> v = queue.shift();    <span class="hljs-keyword">if</span>(v == <span class="hljs-literal">undefined</span>)&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;已经访问过的顶点&#x27;</span>, v);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.adj[v])&#123;      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.marked[w])&#123;        <span class="hljs-built_in">this</span>.edgeTo[w] = v;        <span class="hljs-built_in">this</span>.marked[w] = <span class="hljs-literal">true</span>;        queue.push(w);      &#125;    &#125;  &#125;&#125;</code></pre><p>新增一个函数用于展示图中连接到不同顶点的路径，创建函数<code>pathTo</code>用来存储与指定顶点有共同边的所有顶点。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.edgeTo = edgeTo;  <span class="hljs-built_in">this</span>.pathTo = pathTo;  <span class="hljs-built_in">this</span>.hasPathTo = hasPathTo;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathTo</span>(<span class="hljs-params">v</span>)</span>&#123;  <span class="hljs-keyword">var</span> source = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.hasPathTo(v))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-keyword">var</span> path = [];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = v; i != source; i = <span class="hljs-built_in">this</span>.edgeTo[i])&#123;    path.push(i);  &#125;  path.push(source);  <span class="hljs-keyword">return</span> path;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPathTo</span>(<span class="hljs-params">v</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.marked[v];&#125;</code></pre><p>测试程序: 顶点0-4的最短路径</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> g = <span class="hljs-keyword">new</span> Graph(<span class="hljs-number">5</span>);g.bfs(<span class="hljs-number">0</span>);g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);g.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);g.addEdge(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);g.addEdge(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<span class="hljs-keyword">var</span> vertex = <span class="hljs-number">4</span>;<span class="hljs-keyword">var</span> paths = g.pathTo(vertex);<span class="hljs-keyword">var</span> pathStr = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">while</span>(paths.length &gt; <span class="hljs-number">0</span>)&#123;  <span class="hljs-keyword">if</span>(paths.length &gt; <span class="hljs-number">1</span>)&#123;    pathStr = paths.pop() + <span class="hljs-string">&#x27;-&#x27;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    pathStr += paths.pop();  &#125;&#125;<span class="hljs-built_in">console</span>.log(pathStr); <span class="hljs-comment">// 0-2-4</span></code></pre><h4 id="拓扑排序-TopSort"><a href="#拓扑排序-TopSort" class="headerlink" title="拓扑排序 (TopSort)"></a>拓扑排序 (TopSort)</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2020/12/20/BST/"/>
    <url>/2020/12/20/BST/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树的子节点不超过2个。</p><ul><li><code>树</code>是计算机科学中经常用到的一种数据结构。  </li><li><code>树</code>是一种<code>非线性</code>的数据结构，以<code>分层的方式</code>存储数据。  </li><li><code>树</code>被用来存储具有<code>层级结构</code>的数据。</li><li>二叉树<code>添加</code>、<code>删除</code>、<code>查找</code>都非常快。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>树</code>是由一组<code>以边连接的节点</code>组成。</p><ul><li><code>根节点</code>： 一颗树最上面的节点称为<code>根节点</code>。</li><li><code>父节点</code>：如果一个节点下面连接很多个节点，那么这个节点称为下面节点的<code>父节点</code>，下面的节点称为这个节点的<code>子节点</code>。</li><li><code>叶子节点</code>：没有任何子节点的节点称为叶子节点。</li><li><code>路径</code>：从一个节点到另一个节点的<code>这一组边称为路径</code>。</li><li><code>键</code>：节点当中的值。</li><li><code>左节点</code>：二叉树父节点下左边的节点。</li><li><code>右节点</code>：二叉树父节点下右边的节点。</li></ul><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>特点： <strong>相对较小的值保存在左节点</strong>，<strong>相对较大的值保存在右节点</strong>。这一特性使得它的查找效率很高。</p><h2 id="实现二叉查找树"><a href="#实现二叉查找树" class="headerlink" title="实现二叉查找树"></a>实现二叉查找树</h2><p>二叉树新增步骤</p><ol><li>先实例化要新增的节点<code>data</code>，<code>new Node(data, null, null)</code>。</li><li>遍历二叉树。</li></ol><ul><li>如果不存在根节点,则将<code>data</code>设置为根节点。</li><li>如果存在根节点，并且data &lt; root.data，先将根节点指针指向左节点，如果左节点为空，则将<code>data</code>设置为左节点，否则，沿着左节点继续向下查找，将<code>data</code>与root.left.data进行比较大小，小于则设置为左节点，大于则设置为右节点。左右节点不为空则一直向下查找。</li><li>如果存在根节点，并且 data &gt; root.data，先将根节点指针指向右节点，如果右节点为空，则将<code>data</code>设置为右节点，否则，沿着右节点继续向下查找，将<code>data</code>与root.right.data进行比较大小，小于则设置为左节点，大于则设置为右节点。左右节点不为空则一直向下查找，直到找到空节点，放到对应的左右节点的位置。</li></ul><p><strong>代码实现</strong>  </p><pre><code class="hljs js"><span class="hljs-comment">// 节点类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">data, left, right</span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = data;  <span class="hljs-built_in">this</span>.left = left;  <span class="hljs-built_in">this</span>.right = right;  <span class="hljs-built_in">this</span>.show = show;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BST</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.insert = insert;  <span class="hljs-built_in">this</span>.inOrder = inOrder;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span>(<span class="hljs-params">data</span>)</span>&#123;  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> Node(data, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.root == <span class="hljs-literal">null</span>)&#123;    <span class="hljs-built_in">this</span>.root = node;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">let</span> parent;    <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.root;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      parent = current; <span class="hljs-comment">// copy对象到parent，让current进行移动</span>      <span class="hljs-keyword">if</span>(data &lt; current.data)&#123;        current = current.left; <span class="hljs-comment">// 将指针向左移动</span>        <span class="hljs-keyword">if</span>(current == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//当左节点为空时，设置为左节点，否则继续向下一层遍历</span>          parent.left = node;          <span class="hljs-keyword">break</span>;        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        current = current.right;        <span class="hljs-keyword">if</span>(current == <span class="hljs-literal">null</span>)&#123;          parent.right = node;          <span class="hljs-keyword">break</span>;        &#125;      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// 中序遍历</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inOrder</span>(<span class="hljs-params">node</span>)</span>&#123;  <span class="hljs-keyword">if</span>(node !== <span class="hljs-literal">null</span>)&#123;    inOrder(node.left);    <span class="hljs-built_in">console</span>.log(node.show() + <span class="hljs-string">&#x27;&#x27;</span>);    inOrder(node.right);  &#125;&#125;</code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>从根节点开始遍历，一直向左节点遍历，直到找到最小的左节点，再向父节点和右节点遍历，再往父节点的父节点遍历。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inOrder</span>(<span class="hljs-params">node</span>)</span>&#123;  <span class="hljs-keyword">if</span>(node !== <span class="hljs-literal">null</span>)&#123;    inOrder(node.left);    <span class="hljs-built_in">console</span>.log(node.show() + <span class="hljs-string">&#x27;&#x27;</span>);    inOrder(node.right);  &#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">var</span> nums = <span class="hljs-keyword">new</span> BST();nums.insert(<span class="hljs-number">23</span>);nums.insert(<span class="hljs-number">45</span>);nums.insert(<span class="hljs-number">16</span>);nums.insert(<span class="hljs-number">37</span>);nums.insert(<span class="hljs-number">3</span>);nums.insert(<span class="hljs-number">99</span>);nums.insert(<span class="hljs-number">22</span>);inOrder(nums.root);</code></pre><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>先输出自己的值，再输出左节点的值，最后输出右节点的值。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preOrder</span>(<span class="hljs-params">node</span>)</span>&#123;  <span class="hljs-keyword">if</span>(node !== <span class="hljs-literal">null</span>)&#123;    <span class="hljs-built_in">console</span>.log(node.show() + <span class="hljs-string">&#x27; &#x27;</span>);    preOrder(node.left);    preOrder(node.right);  &#125;&#125;<span class="hljs-comment">// preOrder: 23 16 3 22 45 37 99</span></code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>根据例子的输出顺序去理解，实际上是递归的方式不一样</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postOrder</span>(<span class="hljs-params">node</span>)</span>&#123;  <span class="hljs-keyword">if</span>(node !== <span class="hljs-literal">null</span>)&#123;    postOrder(node.left);    postOrder(node.right);    <span class="hljs-built_in">console</span>.log(node.show() + <span class="hljs-string">&#x27; &#x27;</span>);  &#125;&#125;<span class="hljs-comment">// postOrder: 3 22 16 37 99 45 23</span></code></pre><h2 id="在二叉树上进行查找"><a href="#在二叉树上进行查找" class="headerlink" title="在二叉树上进行查找"></a>在二叉树上进行查找</h2><ul><li>查找给定值</li><li>查找最小值</li><li>查找最大值</li></ul><h3 id="查找最小值和最大值"><a href="#查找最小值和最大值" class="headerlink" title="查找最小值和最大值"></a>查找最小值和最大值</h3><ul><li><p>查找最小值<br>因为最小值在左节点上，因此查找最小值只需要遍历到最后一个左节点。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMin</span>(<span class="hljs-params">node</span>)</span>&#123;  <span class="hljs-keyword">if</span>(node !== <span class="hljs-literal">null</span>)&#123;    findMin(node.left);    <span class="hljs-built_in">console</span>.log(node.show());  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMin</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.root;  <span class="hljs-keyword">if</span>(current.left != <span class="hljs-literal">null</span>)&#123;    current = current.left;  &#125;  <span class="hljs-keyword">return</span> current.data;&#125;</code></pre></li><li><p>查找最大值<br>因为最大值在右节点上，遍历右子树直到找到最后一个节点，该节点的值即为最大值。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMax</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.root;  <span class="hljs-keyword">if</span>(current.right != <span class="hljs-literal">null</span>)&#123;    current = current.right;  &#125;  <span class="hljs-keyword">return</span> current.data;&#125;</code></pre><p>测试代码</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> nums = <span class="hljs-keyword">new</span> BST();nums.insert(<span class="hljs-number">23</span>);nums.insert(<span class="hljs-number">45</span>);nums.insert(<span class="hljs-number">16</span>);nums.insert(<span class="hljs-number">37</span>);nums.insert(<span class="hljs-number">3</span>);nums.insert(<span class="hljs-number">99</span>);nums.insert(<span class="hljs-number">22</span>);<span class="hljs-keyword">let</span> min = getMin();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;min&#x27;</span>, min);<span class="hljs-keyword">let</span> min = getMax();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;max&#x27;</span>, max);</code></pre></li></ul><h3 id="查找给定值"><a href="#查找给定值" class="headerlink" title="查找给定值"></a>查找给定值</h3><p>比较法，层层比较，小的向左子树遍历查找，大的向右子树遍历查找。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params">data</span>) </span>&#123;  <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.root;  <span class="hljs-keyword">let</span> parent;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    parent = current;    <span class="hljs-keyword">if</span>(data &lt; current.data)&#123;      current = current.left;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; current.data) &#123;      current = current.right;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> current;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">data</span>)</span>&#123;  <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.root;  <span class="hljs-keyword">while</span>(current != <span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">if</span>(current.data == data)&#123;      <span class="hljs-keyword">return</span> current;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &lt; current.data)&#123;      current = current.left;    &#125; <span class="hljs-keyword">else</span> &#123;      current = current.right;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre><h2 id="从二叉树上删除节点"><a href="#从二叉树上删除节点" class="headerlink" title="从二叉树上删除节点"></a>从二叉树上删除节点</h2><ol><li>判断当前节点是否包含待删除的数据，如果包含则删除该节点，如果不包含，则比较当前节点上的数据和待删除的数据，如果待删除的数据小于当前节点上的数据，则移至当前节点的左节点继续比较，如果待删除的数据大于当前节点的数据，则移至右节点继续比较。</li><li>如果待删除的节点是叶子节点，那么只需要将从父节点指向它的链接指向null。</li><li>如果待删除的节点只包含一个子节点，那么原本指向它的子节点就得做些调整，使其指向它的子节点。</li><li>**如果待删除的节点包含两个子节点，正确的做法有2种：</li></ol><ul><li>查找待删除节点左子树上的最大值。</li><li>查找其右子树上的最小值。<blockquote><p>其实就是找到它离得最近的子节点</p></blockquote></li></ul><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">data</span>)</span>&#123;  root = removeNode(<span class="hljs-built_in">this</span>.root, data);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNode</span>(<span class="hljs-params">node, data</span>)</span>&#123;  <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-keyword">if</span>(data == node.data)&#123;    <span class="hljs-comment">//没有子节点的叶子节点</span>    <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">//没有左子节点的节点</span>    <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span>)&#123;      <span class="hljs-keyword">return</span> node.right;    &#125;    <span class="hljs-comment">//没有右子节点的节点</span>    <span class="hljs-keyword">if</span>(node.right == <span class="hljs-literal">null</span>)&#123;      <span class="hljs-keyword">return</span> node.left;    &#125;    <span class="hljs-comment">//有两个子节点的节点</span>    <span class="hljs-keyword">let</span> tempNode = getSmallest(node.right); <span class="hljs-comment">// 查找到右节点的最小值</span>    node.data = tempNode.data; <span class="hljs-comment">// ??</span>    node.right = removeNode(node.right, tempNode.data); <span class="hljs-comment">// ??</span>    <span class="hljs-keyword">return</span> node;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data &lt; node.data)&#123;    node.left = removeNode(node.left, data);    <span class="hljs-keyword">return</span> node;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; node.data)&#123;    node.right = removeNode(node.right, data);    <span class="hljs-keyword">return</span> node;  &#125;&#125;</code></pre><h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>BST的一个用途是记录一组数据集中数据出现的次数。<br>需要先在<code>Node</code>中新增次数的属性，以及更新次数。</p><pre><code class="hljs js">funciton <span class="hljs-function"><span class="hljs-title">Node</span>(<span class="hljs-params">data, left, right</span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = data;  <span class="hljs-built_in">this</span>.count = <span class="hljs-number">1</span>;  <span class="hljs-built_in">this</span>.left = left;  <span class="hljs-built_in">this</span>.right = right;  <span class="hljs-built_in">this</span>.show = show;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">data</span>)</span>&#123;  <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.find(data);  current.count++;  <span class="hljs-keyword">return</span> current;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合（Set）</title>
    <link href="/2020/12/14/set/"/>
    <url>/2020/12/14/set/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>集合</code>是由一组<code>无序</code>但彼此之间又有一定相关性的成员组成的，每个成员在集合中<code>只能出现一次</code>。  </p><ul><li>不包含任何成员的集合称为<code>空集</code>，<code>全集</code>则是包含一切可能成员的集合。</li><li>如果两个集合的成员完全相同，则称这两个集合相等。</li><li>如果一个集合中所有的成员都属于另外一个集合，则前一个集合称为后一个集合的<code>子集</code>。</li></ul><h2 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h2><p>跟数学上集合的操作一样。</p><ul><li>并集<br>将两个集合的成员进行合并，得到一个新的集合。</li><li>交集<br>两个集合中共同存在的成员组成一个新的集合。</li><li>补集<br>属于一个集合而不属于另一个集合的成员组成的集合。</li></ul><h2 id="Set类的实现"><a href="#Set类的实现" class="headerlink" title="Set类的实现"></a>Set类的实现</h2><p>Set类的实现基于数组，数组用来存储数据。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.dataStore = [];  <span class="hljs-built_in">this</span>.add = add;  <span class="hljs-built_in">this</span>.remove = remove;  <span class="hljs-built_in">this</span>.size = size;  <span class="hljs-built_in">this</span>.union = union; <span class="hljs-comment">// 并集</span>  <span class="hljs-built_in">this</span>.intersect = intersect; <span class="hljs-comment">// 交集</span>  <span class="hljs-built_in">this</span>.subset = subset; <span class="hljs-comment">// 子集</span>  <span class="hljs-built_in">this</span>.difference = difference; <span class="hljs-comment">// 补集</span>  <span class="hljs-built_in">this</span>.show = show; <span class="hljs-comment">// 展示集合中的元素</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">data</span>) </span>&#123;  <span class="hljs-comment">// 因为集合内不能存在相同的元素，所以添加之前先查重</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dataStore.indexOf(data) &lt; <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">// 不存在则添加</span>    <span class="hljs-built_in">this</span>.dataStore.push(data);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">data</span>) </span>&#123;  <span class="hljs-keyword">let</span> pos = <span class="hljs-built_in">this</span>.dataStore.indexOf(data);  <span class="hljs-keyword">if</span> (pos &gt; -<span class="hljs-number">1</span>) &#123;    <span class="hljs-built_in">this</span>.dataStore.splice(pos, <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataStore;&#125;<span class="hljs-comment">// 是否包含</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span>(<span class="hljs-params">data</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dataStore.indexOf(data) &gt; -<span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">// 求并集。先将其中一个保存到temp，再遍历第二个将不属于temp中的继续添加到temp，</span><span class="hljs-comment">// 最后返回temp。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">set</span>) </span>&#123;  <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.dataStore.length; i++) &#123;    temp.add(<span class="hljs-built_in">this</span>.dataStore[i]);  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; set.dataStore.length; i++) &#123;    <span class="hljs-keyword">if</span> (!temp.contains(set.dataStore(i))) &#123;      temp.dataStore.push(set.dataStore(i));    &#125;  &#125;  <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">// 交集。定义一个temp。将2个集合中相同的成员添加到temp中，最后返回。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersect</span>(<span class="hljs-params">set</span>) </span>&#123;  <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.dataStore.length; i++) &#123;    <span class="hljs-keyword">if</span> (set.contains(<span class="hljs-built_in">this</span>.dataStore[i])) &#123;      temp.add(<span class="hljs-built_in">this</span>.dataStore[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">// 是否是一个集合的子集。判断2个集合的size，如果A.size &gt; B.size 那么A肯定不是B的子集。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subset</span>(<span class="hljs-params">set</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.size() &gt; set.size()) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.dataStore.length; i++) &#123;    <span class="hljs-keyword">if</span> (!set.contains(<span class="hljs-built_in">this</span>.dataStore[i])) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">size</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataStore.length;&#125;<span class="hljs-comment">// 补集。两个集合中不属于另一个集合的所有成员。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">difference</span>(<span class="hljs-params">set</span>) </span>&#123;  <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.dataStore.length; i++ ) &#123;    <span class="hljs-keyword">if</span> (!set.contains(<span class="hljs-built_in">this</span>.dataStore[i])) &#123;      temp.add(<span class="hljs-built_in">this</span>.dataStore[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> temp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/2020/12/14/leetcode-206/"/>
    <url>/2020/12/14/leetcode-206/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>LeetCode 206<br>反转一个单链表。<br>示例:</p><pre><code class="hljs js">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL</code></pre><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h2 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h2><ol><li>prev、cur</li><li>prev记录前一个位置，prev总是在cur的后面。</li><li>依次实现局部反转。<pre><code class="hljs js"><span class="hljs-comment">// 核心代码</span><span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 退出条件，当cur=null代表已经遍历完成。</span>  <span class="hljs-keyword">let</span> nextNode = cur.next;<span class="hljs-comment">//记录下一个的位置，使得cur指针后移</span>  cur.next = prev; <span class="hljs-comment">// 链表局部反转。prev初始值为null</span>  prev = cur; <span class="hljs-comment">// prev指针移动</span>  cur = nextNode; <span class="hljs-comment">// cur指针移动 </span>&#125;<span class="hljs-comment">//完整代码</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>, cur = head;  <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">let</span> nextNode = cur.next;    cur.next = prev;    prev = cur;    cur = nextNode;  &#125;  <span class="hljs-keyword">return</span> prev; <span class="hljs-comment">// 返回头指针</span>&#125;</code></pre>时间复杂度： O(n);<br>空间复杂度：O(1);</li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列表</title>
    <link href="/2020/12/14/list/"/>
    <url>/2020/12/14/list/</url>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>关键概念： 列表是一组有序的数据。每个列表中的数据项称为元素。没有任何元素的列表称为空列表。<br>注意:</p><ul><li>列表元素不能太多,否则内存吃不消。</li><li>不需要很长序列查找元素或排序。</li></ul><h2 id="列表的代码实现"><a href="#列表的代码实现" class="headerlink" title="列表的代码实现"></a>列表的代码实现</h2><p>核心方法和属性:<br>    1. 列表长度-size.<br>    2. 添加元素.<br>    3. 删除元素.<br>    4. 插入元素.<br>    5. 查找元素.</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;    <span class="hljs-built_in">this</span>.pos = pos;    <span class="hljs-built_in">this</span>.dataSource = [];    <span class="hljs-built_in">this</span>.find = find;    <span class="hljs-built_in">this</span>.append = append;    <span class="hljs-built_in">this</span>.remove = remove;    <span class="hljs-built_in">this</span>.insert = insert;    <span class="hljs-built_in">this</span>.curPos = curPos;    <span class="hljs-built_in">this</span>.getElement = getElement;    <span class="hljs-built_in">this</span>.contains = contains;    <span class="hljs-built_in">this</span>.toString = toString;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">element</span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.dataSource.length; i++)&#123;        <span class="hljs-keyword">let</span> sub = <span class="hljs-built_in">this</span>.dataSource[i];        <span class="hljs-keyword">if</span>(element === sub)&#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">append</span>(<span class="hljs-params">element</span>)</span>&#123;    <span class="hljs-built_in">this</span>.dataSource[<span class="hljs-built_in">this</span>.size++] = element;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">element</span>)</span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.find(element);    <span class="hljs-keyword">if</span>(index &gt; -<span class="hljs-number">1</span>)&#123;        <span class="hljs-built_in">this</span>.size--;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataSource.splice(index, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span>(<span class="hljs-params">element</span>)</span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.find(element);    <span class="hljs-keyword">if</span>(index &gt; -<span class="hljs-number">1</span>)&#123;        <span class="hljs-built_in">this</span>.size++;        <span class="hljs-built_in">this</span>.dataSource.splice(index + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, element);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getElement</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataSource[<span class="hljs-built_in">this</span>.pos];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curPos</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.pos;&#125;<span class="hljs-comment">// 后一位</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.pos &lt; <span class="hljs-built_in">this</span>.size)&#123;        <span class="hljs-built_in">this</span>.pos++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prev</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.pos &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">this</span>.pos--;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveTo</span>(<span class="hljs-params">position</span>)</span>&#123;    <span class="hljs-built_in">this</span>.pos = position;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span>(<span class="hljs-params">element</span>)</span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.find(element);    <span class="hljs-keyword">if</span>(index &gt; -<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataSource;&#125;<span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List();list.append(<span class="hljs-string">&#x27;1&#x27;</span>);list.append(<span class="hljs-string">&#x27;2&#x27;</span>);list.append(<span class="hljs-string">&#x27;3&#x27;</span>);<span class="hljs-built_in">console</span>.log(list.toString());list.next(); <span class="hljs-comment">// 后移一位,默认初始位置是0,后移一位之后,pos=1.所以返回&#x27;2&#x27;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2020/12/14/Stack/"/>
    <url>/2020/12/14/Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>栈是一种特殊的列表。</li><li>栈是一种高效的数据结构，因为数据只能在栈顶删除或添加,操作很快。 就像洗碗的时候放盘子。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>栈内元素只能通过列表的一端访问,这一端成为栈顶.</li><li>LIFO (last in first out)</li><li>操作新元素又称作 进栈,入栈或压栈.从一个栈删除元素又称作出栈或退栈.</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>入栈</li><li>出栈</li><li>栈顶</li></ul><h2 id="栈代码实现"><a href="#栈代码实现" class="headerlink" title="栈代码实现"></a>栈代码实现</h2><p>核心方法:<br>    1. 使用数组存储数据.<br>    2. 定义一个栈顶. 栈顶默认位置为0,因为栈默认数据为空.<br>    3. 实现入栈方法<br>    4. 实现出栈方法.<br>    5. 实现清空栈的方法.<br>    6. 返回栈顶元素.</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.dataSource = [];    <span class="hljs-built_in">this</span>.top = <span class="hljs-number">0</span>;    <span class="hljs-built_in">this</span>.push = push;    <span class="hljs-built_in">this</span>.pop = pop;    <span class="hljs-built_in">this</span>.peek = peek;    <span class="hljs-built_in">this</span>.clear = clear;    <span class="hljs-built_in">this</span>.length = length;&#125;<span class="hljs-comment">// 入栈</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">element</span>)</span>&#123;    <span class="hljs-comment">// 元素入栈后,栈顶位置发生变化.</span>    <span class="hljs-built_in">this</span>.dataSource[<span class="hljs-built_in">this</span>.top++] = element;&#125;<span class="hljs-comment">// 出栈: 删除栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// 返回栈顶元素.栈顶位置发生变化,this.top - 1;</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataSource[--<span class="hljs-built_in">this</span>.top];&#125;<span class="hljs-comment">// 返回栈顶元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataSource[<span class="hljs-built_in">this</span>.top - <span class="hljs-number">1</span>];<span class="hljs-comment">// 返回栈顶元素</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.top = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">length</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.top;&#125;<span class="hljs-comment">// 栈的应用: 解决回文字符串的问题.</span><span class="hljs-comment">// 思路: 出栈和入栈结果一致则是回文,否则不是.</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>岛屿类问题深度优先遍历框架</title>
    <link href="/2020/12/14/Queue-Island/"/>
    <url>/2020/12/14/Queue-Island/</url>
    
    <content type="html"><![CDATA[<h1 id="岛屿类问题-DFS遍历框架"><a href="#岛屿类问题-DFS遍历框架" class="headerlink" title="岛屿类问题 DFS遍历框架"></a>岛屿类问题 DFS遍历框架</h1><h2 id="遍历要点"><a href="#遍历要点" class="headerlink" title="遍历要点"></a>遍历要点</h2><ol><li><p>访问相邻节点;上下左右.假设当前位置为 (r,c);  </p><p> 上节点坐标(r-1,c)<br> 下节点坐标(r+1,c)<br> 左节点坐标(r,c-1)<br> 右节点坐标(r,c+1)  </p> <br /> ![1-1](island.png)</li></ol><hr><ol start="2"><li><p>边界</p><blockquote><p>row不能超过 <code>grid.length</code>. col不能超过<code>grid[0].length</code></p></blockquote></li><li><p>代码</p><pre><code class="hljs js"><span class="hljs-comment">/* LeetCode200</span><span class="hljs-comment">    * 思路: 把grid想象成r x c的网格,使用双层遍历.依次遍历所有的节点.</span><span class="hljs-comment">      当从第一个发现的陆地(1)开始深度遍历,污染他的上下左右.直到没有连接为止.</span><span class="hljs-comment">      因为发现一个就会暴露一块岛屿的位置,所有在遍历过程中,发现几次就说明存在</span><span class="hljs-comment">      几个岛屿.</span><span class="hljs-comment">      发现的条件 grid[r][c] = 1.</span><span class="hljs-comment">      为了避免重复将已经遍历过的陆地(1)进行修改grid[r][c] = 2;</span><span class="hljs-comment">      最后 numsIslands 的次数就是岛屿的个数.</span><span class="hljs-comment">      核心代码: </span><span class="hljs-comment">        1. 发现陆地grid[r][c]=1,进行深度遍历,查找他的上下左右节点是否存在相连接的陆地.</span><span class="hljs-comment">        2. 统计数 numsIsland 增加.</span><span class="hljs-comment">        2. 将已经污染过的陆地进行着色 grid[r][c] = 2;</span><span class="hljs-comment">        3. 遍历结束,返回 numsIsland.</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">var</span> grid = [        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]    ];        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gridDfs</span>(<span class="hljs-params">grid, r, c</span>)</span>&#123;        <span class="hljs-keyword">let</span> row = grid.length;        <span class="hljs-keyword">let</span> nc = grid[<span class="hljs-number">0</span>].length;        grid[r][c] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 已经遍历过的</span>        <span class="hljs-keyword">if</span>(r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r-<span class="hljs-number">1</span>][c] == <span class="hljs-number">1</span>)&#123;            gridDfs(grid, r-<span class="hljs-number">1</span>, c);        &#125;        <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; row &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-number">1</span>)&#123;            gridDfs(grid, r+<span class="hljs-number">1</span>, c);        &#125;        <span class="hljs-keyword">if</span>(c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123;            gridDfs(grid, r, c-<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span>(c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123;            gridDfs(grid, r, c+<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArea</span>(<span class="hljs-params">r, c</span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].length;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numsIsland</span>(<span class="hljs-params">grid</span>)</span>&#123;        <span class="hljs-keyword">let</span> row = grid.length;        <span class="hljs-keyword">if</span>(row.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> col = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">let</span> num_islands = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; row; ++r) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>; c &lt; col; ++c) &#123;                <span class="hljs-keyword">if</span> (grid[r][c] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 找到陆地才会进入循环.直到未找到陆地则会退出dfs</span>                    ++num_islands;                    gridDfs(grid, r, c);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> num_islands;    &#125;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grid&#x27;</span>, numsIsland(grid));</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>岛屿问题</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2020/12/14/Queue/"/>
    <url>/2020/12/14/Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>特点: FIFO, 先进先出.</p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>不按照先进先出的顺序,而是按照优先级排列. 比如医院急诊科,按照病人的紧急程度进行排列.</p><h2 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作:"></a>主要操作:</h2><ul><li>入队</li><li>出队</li></ul><h2 id="队列代码实现"><a href="#队列代码实现" class="headerlink" title="队列代码实现"></a>队列代码实现</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.dataStore = []; <span class="hljs-comment">// 队列初始数据</span>  <span class="hljs-built_in">this</span>.enqueue = enqueue; <span class="hljs-comment">// 入队</span>  <span class="hljs-built_in">this</span>.dequeue = dequeue; <span class="hljs-comment">// 出队</span>  <span class="hljs-built_in">this</span>.front = front; <span class="hljs-comment">// 队首</span>  <span class="hljs-built_in">this</span>.back = back; <span class="hljs-comment">// 队尾</span>  <span class="hljs-built_in">this</span>.toString = toString; <span class="hljs-comment">// 显示队列里面的内容</span>  <span class="hljs-built_in">this</span>.empty = empty; <span class="hljs-comment">// 是否为空队列</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueue</span>(<span class="hljs-params">element</span>)</span>&#123;  <span class="hljs-built_in">this</span>.dataStore.push(element);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataStore.shift();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">front</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataStore[<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">back</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataStore[<span class="hljs-built_in">this</span>.dataStore.length - <span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">empty</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataStore.length == <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>先比较个位数大小,再比较十位数大小.<br>比如: 91, 46, 85, 15, 92, 35, 31, 22<br>第一次比较<br>Bin 0:<br>Bin 1: 91, 31<br>Bin 2: 92, 22<br>Bin 3:<br>Bin 4:<br>Bin 5: 85, 15, 35<br>Bin 6: 46<br>Bin 7:<br>Bin 8:<br>Bin 9:<br>第一次比较结果 91, 31, 92, 22, 85, 15, 35, 46<br>第二次比较十位数<br>Bin 0:<br>Bin 1: 15<br>Bin 2: 22<br>Bin 3: 31, 35<br>Bin 4: 46<br>Bin 5:<br>Bin 6:<br>Bin 7:<br>Bin 8: 85<br>Bin 9: 91, 92<br>第二次比较结果: 15, 22, 31, 35, 46, 85, 91, 92</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distribute</span>(<span class="hljs-params">nums, queues, n, digit</span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;    <span class="hljs-keyword">if</span>(digit == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 个位</span>      queues[nums[i%<span class="hljs-number">10</span>]].enqueue(nums[i]); <span class="hljs-comment">// 取余数,也就是个位数.保存到盒子中</span>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 十位</span>      queues[<span class="hljs-built_in">Math</span>.floor(nums[i] / <span class="hljs-number">10</span>)].enqueue(nums[i]);    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collect</span>(<span class="hljs-params">queues, nums</span>)</span>&#123;  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> digit = <span class="hljs-number">0</span>; digit &lt; <span class="hljs-number">10</span>; ++digit)&#123;    <span class="hljs-keyword">while</span>(!queues[digit].empty())&#123;      nums[i++] = queues[digit].dequeue();    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispArray</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i)&#123;    <span class="hljs-built_in">console</span>.log(arr[i] + <span class="hljs-string">&#x27; &#x27;</span>);  &#125;&#125;<span class="hljs-keyword">var</span> queues = [];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)&#123;  queues[i] = <span class="hljs-keyword">new</span> Queue(); <span class="hljs-comment">// 初始化十个队列对象,相当于10个盒子</span>&#125;<span class="hljs-keyword">var</span> nums = []; <span class="hljs-comment">// 随机生成10个,100以内的数字</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)&#123;  nums[i] = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">101</span>));&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before radix sort: &#x27;</span>);dispArray(nums);distribute(nums, queues, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);collect(queues, nums);distribute(nums, queues, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);collect(queues, nums);dispArray(nums);</code></pre><h2 id="广度优先搜索-BFS-和队列"><a href="#广度优先搜索-BFS-和队列" class="headerlink" title="广度优先搜索(BFS) 和队列"></a>广度优先搜索(BFS) 和队列</h2><blockquote><p>广度优先搜索的一个常见应用是找出根节点到目标节点的最短路径.在本文中,我们提供了一个示例来解释在BFS算法中是如何逐步应用队列的.</p></blockquote><h2 id="岛屿数量问题"><a href="#岛屿数量问题" class="headerlink" title="岛屿数量问题"></a>岛屿数量问题</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：</p><pre><code class="hljs js">输入：grid = [    [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],    [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],    [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],    [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]输出：<span class="hljs-number">1</span></code></pre><p>示例 2：</p><pre><code class="hljs js">输入：grid = [    [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],    [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],    [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],    [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]]输出：<span class="hljs-number">3</span></code></pre><p>提示:</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</code></li></ul><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> numIslands = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;    &#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>散列表（HashTable）</title>
    <link href="/2020/12/14/hashTable/"/>
    <url>/2020/12/14/hashTable/</url>
    
    <content type="html"><![CDATA[<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><ul><li>散列是一种常用的数据存储结构，散列后的数据可以快速的<code>插入</code>、<code>删除</code>和<code>取用</code>。 </li><li>散列使用的数据结构叫做<code>散列表</code>。</li><li>散列的<code>查找效率很低</code>。<br>总上描述，散列的特点有点类似于<code>链表</code>。</li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ol><li>散列表存储数据时，通过一个<code>散列函数</code>将<code>键</code>映射为一个数字，这个数字的范围是0-散列表的长度。</li><li>理想情况下，散列函数会将每个键值映射为一个唯一的数组索引，然而，键的数量是无限的，数组的长度<br>是有限的。两个键映射成同一个值的现象称为<code>碰撞</code>。</li><li>散列表是基于数组去实现的，数组的长度应该是一个<code>质数</code>，为何？</li></ol><ul><li>计算数组下标的时候是<code>取余运算</code>，确保散列表中用来存储数据的<code>数组大小是一个质数可以避免发生碰撞</code>。</li><li>数组的长度应该在100以上，这样可以保证散列表中的数据分布的更均匀。</li><li>霍纳算法，散列函数的处理字符串数据，先计算字符串中的ASCII，然后乘以一个较小的质数。</li></ul><p>核心：散列函数和碰撞处理（开链法和线性探测法）</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><pre><code class="hljs js"><span class="hljs-comment">// 构造函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HashTable</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.table = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">137</span>);  <span class="hljs-built_in">this</span>.simpleHash = simpleHash;  <span class="hljs-built_in">this</span>.showDistro = showDistro;  <span class="hljs-built_in">this</span>.put = put;  <span class="hljs-built_in">this</span>.get = get;  <span class="hljs-built_in">this</span>.values = [];<span class="hljs-comment">//为线性探测法使用</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showDistro</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.table.length; i++)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.table[i] != <span class="hljs-literal">undefined</span>)&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;i=&quot;</span> +  <span class="hljs-built_in">this</span>.table[i]);    &#125;  &#125;&#125;</code></pre><p>选择一个<code>散列函数</code>。</p><ul><li>如果<code>键</code>是<code>整形</code>，最简单的<code>散列函数是以数组的长度对键值取余</code>。这种散列方式称为<code>除留余数法</code>。</li></ul><p><strong>简单的散列函数</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">simpleHash</span>(<span class="hljs-params">string</span>)</span>&#123; <span class="hljs-comment">// 依然会发生碰撞</span>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; string.length; i++)&#123;    total += string.charCodeAt(i);  &#125;  <span class="hljs-keyword">return</span> total % <span class="hljs-built_in">this</span>.table.length;&#125;</code></pre><p>运行以下示例，依然会发生碰撞。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> someNames = [<span class="hljs-string">&#x27;David&#x27;</span>, <span class="hljs-string">&#x27;Jennifer&#x27;</span>, <span class="hljs-string">&#x27;Donnie&#x27;</span>, <span class="hljs-string">&#x27;Raymond&#x27;</span>, <span class="hljs-string">&#x27;Cynthia&#x27;</span>, <span class="hljs-string">&#x27;Mike&#x27;</span>, <span class="hljs-string">&#x27;Claython&#x27;</span>, <span class="hljs-string">&#x27;Danny&#x27;</span>, <span class="hljs-string">&#x27;Jonathan&#x27;</span>];</code></pre><p><strong>使用霍纳算法后的散列函数</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">betterHash</span>(<span class="hljs-params">string, arr</span>)</span>&#123;  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> H = <span class="hljs-number">37</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; string.length; i++)&#123;    total += H * total + string.charCodeAt(i);  &#125;  <span class="hljs-keyword">return</span> total % arr.length;&#125;</code></pre><h2 id="散列表的碰撞处理"><a href="#散列表的碰撞处理" class="headerlink" title="散列表的碰撞处理"></a>散列表的碰撞处理</h2><ol><li>开链法<blockquote><p>开链法是指实现散列表的底层数组中，每个数组元素又是一个新的数据结构，比如另一个数组，这样就可以存储多个键了。<br>使用二维数组进行存储。<br>比如 a 散列之后的 index = 0， b散列之后的 index 也是 0，那么可以把a.data 存储在 二维数组的[0][0]位置，<br>b存储在数组[0][1]的位置。</p></blockquote></li></ol><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">put</span>(<span class="hljs-params">key, data</span>)</span>&#123;  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> pos = <span class="hljs-built_in">this</span>.betterHash(key);  <span class="hljs-comment">// key，data存储的位置相隔 1</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.table[pos][index] == <span class="hljs-literal">undefined</span>)&#123;    <span class="hljs-built_in">this</span>.table[pos][index+<span class="hljs-number">1</span>] = data;    ++index;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">this</span>.table[pos][index] != <span class="hljs-literal">undefined</span>)&#123;      ++index;    &#125;    <span class="hljs-built_in">this</span>.table[pos][index+<span class="hljs-number">1</span>] = data;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">key</span>)</span>&#123;  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> pos = <span class="hljs-built_in">this</span>.betteHash(key);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.table[pos][index] == key) &#123; <span class="hljs-comment">// 找到对应的key</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.table[pos][index+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 返回data</span>  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">this</span>.table[pos][index] != key)&#123;      index+=<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.table[pos][index+<span class="hljs-number">1</span>];  &#125;  &#125;</code></pre><ol start="2"><li>线性探测法<br><code>线性探测法</code>又叫做<code>开放寻址散列</code>。其原理是当发生碰撞时，线性探测法检测列表中的下一个位置是否为空。如果<br>为空，就将数据存入该位置，如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。该技术基于这样<br>一个事实：<code>每个散列表都会有很多空的单元格，可以使用它们来存储数据</code>。</li></ol><p><strong>开链法和线性探测法的选择方法</strong></p><ul><li>如果数组的大小是待存储数据个数的1.5倍，那么使用<code>开链法</code>。</li><li>如果数组的大小是待存储数据的两倍及两倍以上时，则使用<code>线性探测法</code>。</li></ul><p>使用<code>线性探测法</code>重写<code>put</code>、<code>get</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">put</span>(<span class="hljs-params">key, data</span>) </span>&#123;  <span class="hljs-keyword">var</span> pos = <span class="hljs-built_in">this</span>.betterHash(key);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.table[pos] == <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-built_in">this</span>.table[pos] = key;    <span class="hljs-built_in">this</span>.values[pos] = data;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">this</span>.table[pos] !== <span class="hljs-literal">undefined</span>)&#123;      pos++;    &#125;    <span class="hljs-built_in">this</span>.table[pos] = key;    <span class="hljs-built_in">this</span>.values[pos] = data;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">key</span>) </span>&#123;  <span class="hljs-keyword">var</span> hash = -<span class="hljs-number">1</span>;  hash = <span class="hljs-built_in">this</span>.betterHash(key);  <span class="hljs-keyword">if</span> (hash &gt; -<span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = hash; i &lt; <span class="hljs-built_in">this</span>.table.length; i++) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.table[hash] == key) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.values[hash];      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;&#125;</code></pre><p><strong>散列完整版代码实现</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HashTable</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.table = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">137</span>); <span class="hljs-comment">// 存储数据的数组</span>  <span class="hljs-built_in">this</span>.betterHash = betterHash; <span class="hljs-comment">// 以字符串为键</span>  <span class="hljs-built_in">this</span>.simpleHash = simpleHash; <span class="hljs-comment">// 以数子为键</span>  <span class="hljs-built_in">this</span>.put = put; <span class="hljs-comment">// 存入</span>  <span class="hljs-built_in">this</span>.get = get; <span class="hljs-comment">// 读取</span>  <span class="hljs-built_in">this</span>.values = [];&#125;<span class="hljs-comment">// 使用字符的ASCII作为计算的基础</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">simpleHash</span>(<span class="hljs-params">data</span>) </span>&#123;  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;    total += data.charCodeAt(i);  &#125;  <span class="hljs-keyword">return</span> total % <span class="hljs-built_in">this</span>.table.length;&#125;<span class="hljs-comment">// 减少碰撞的发生</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">betterHash</span>(<span class="hljs-params">string, arr</span>) </span>&#123;  <span class="hljs-keyword">const</span> H = <span class="hljs-number">37</span>;  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; string.length; i++) &#123;    total += H * total + string.charCodeAt(i);  &#125;  total = total % arr.length; <span class="hljs-comment">// 这里的arr指的是this.table</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(total);&#125;<span class="hljs-comment">// put,get 开链法,二维数组, index =&gt; key, inde+1 =&gt; data</span><span class="hljs-comment">// put,get 线性探测法,关键点直到找到一个为空的</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>散列</code>的实现原理，使用数组存储数据假定为<code>array</code>，而存储的下标通过一个散列函数计算得出假定为<code>index</code>。<br>如果是以字符串为key进行散列计算。数据下标很容易发生重复，为了解决重复可以使用开链法和线性探测法（开放寻址散列）。<br>使用<code>array[index]</code>存储<code>data</code>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典</title>
    <link href="/2020/12/14/Dictionary/"/>
    <url>/2020/12/14/Dictionary/</url>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><ol><li><code>字典</code>是一种以<code>键值对</code>形式存储数据的数据结构。</li><li>JavaScript中的<code>Object</code>类就是以字典的形式设计的。</li></ol><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><pre><code class="hljs js"><span class="hljs-comment">// 定义字典类</span><span class="hljs-comment">// 字典类的基础是Array类，而不是Object类。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dictionary</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.dataStore = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">//使用array是为了让其可以遍历</span>  <span class="hljs-built_in">this</span>.add = add;  <span class="hljs-built_in">this</span>.find = find;  <span class="hljs-built_in">this</span>.remove = remove;  <span class="hljs-built_in">this</span>.showAll = showAll;  <span class="hljs-built_in">this</span>.clear = clear;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">key, value</span>)</span>&#123;  <span class="hljs-built_in">this</span>.dataStore[key] = value;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">key</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dataStore[key];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">key</span>)</span>&#123;  <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.dataStore[key];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showAll</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// this.dataStore是数组，数组也是由Object实现的，所以支持</span>  <span class="hljs-comment">// Object.keys去拿到数组的key</span>  <span class="hljs-comment">// ①不加this。function里面就无法访问到dataStore</span>  <span class="hljs-comment">// Object.keys(this.dataStore).forEach(function(key)&#123;</span>  <span class="hljs-comment">//   console.log(key + &#x27;&gt;&#x27; + this.dataStore[key]);</span>  <span class="hljs-comment">// &#125;, this);</span>  <span class="hljs-comment">// 返回一个有序的结果:添加sort方法</span>  <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.dataStore).sort().forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&#x27;&gt;&#x27;</span> + <span class="hljs-built_in">this</span>.dataStore[key]);  &#125;, <span class="hljs-built_in">this</span>);&#125;<span class="hljs-comment">// ②不能使用数组的length属性，因为当字符串作为key时，数组的length就不准了</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;  <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.dataStore).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>)</span>&#123;    ++n;  &#125;);  <span class="hljs-keyword">return</span> n;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.dataStore).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>)</span>&#123;    <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.dataStore[key];  &#125;, <span class="hljs-built_in">this</span>);&#125;<span class="hljs-comment">// Test</span><span class="hljs-keyword">let</span> dic = <span class="hljs-keyword">new</span> Dictionary();dic.add(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;CK&quot;</span>);dic.add(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<span class="hljs-built_in">console</span>.log(dic.showAll());<span class="hljs-built_in">console</span>.log(dic.find(<span class="hljs-string">&quot;age&quot;</span>)); dic.remove(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-built_in">console</span>.log(dic.showAll());</code></pre><h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach"></a>Array.prototype.forEach</h2><ul><li><p>用法：<br>arr.forEach(callback(currentValue [, index [, array]])[, thisArg])  </p></li><li><p>参数：</p><ul><li><code>callback</code><ul><li><code>currentValue</code> 数组中正在处理的当前元素</li><li><code>index</code> 数组中正在处理的当前元素的索引（可选）</li><li><code>array</code> 原数组（可选）</li></ul></li><li><code>thisArg</code> callback中用作this的值。(可选)</li></ul></li></ul><h2 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> nums = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();nums[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;nums[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(nums.length); <span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> books = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();books[<span class="hljs-string">&#x27;js&#x27;</span>] = <span class="hljs-string">&quot;《你不知道的javascript》&quot;</span>;books[<span class="hljs-string">&#x27;java&#x27;</span>] = <span class="hljs-string">&quot;《大话java》&quot;</span>;<span class="hljs-built_in">console</span>.log(books.length); <span class="hljs-comment">// 0</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2020/12/11/linkedlist/"/>
    <url>/2020/12/11/linkedlist/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h2><ol><li>添加和删除比较麻烦, 因为添加或删除之后,最坏的情况下所有元素的下标都会发生变化.</li><li>js中的数组是使用对象实现的,与其他语言相比,效率很低.</li></ol><h2 id="数组的优点"><a href="#数组的优点" class="headerlink" title="数组的优点"></a>数组的优点</h2><ol><li>随机访问.只要给定下标就可以找到. 所有查找算是数组的优点.</li></ol><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><ol><li>添加、删除快。</li><li>查找慢，每个都要从头开始查找。</li></ol><p>链表的概念<br><code>链表</code>是由一组<code>节点</code>组成的集合。每个<code>节点</code>都使用一个对象的引用指向它的<code>后继</code>。指向另一个节点<br>的引用叫做<code>链</code>。</p><p>头节点： 链表开始的位置  </p><blockquote><p>疑问链表的头节点Head是否真实存在，还是只是为了定义一个链表的开始位置。头节点是否存在值？</p></blockquote><p>链表的末尾指向<code>null</code>  </p><h3 id="单链表的代码实现"><a href="#单链表的代码实现" class="headerlink" title="单链表的代码实现"></a>单链表的代码实现</h3><ol><li>首先要实现一个<code>节点类</code>。节点包含数据<code>element</code>和<code>next</code></li><li>链表的操作</li></ol><ul><li>插入</li><li>删除<ul><li>删除之前得先找到<code>前一个元素</code>，让<code>前一个元素</code>指向<code>待删除元素</code>的next。</li></ul></li></ul><ul><li>insert</li><li>remove</li><li>find、findPrevious</li><li>display 返回链表中的元素值<pre><code class="hljs js"><span class="hljs-comment">// Node 节点类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">element</span>)</span>&#123;  <span class="hljs-built_in">this</span>.element = element; <span class="hljs-comment">// 表示节点上的数据</span>  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向下一个节点的链接（地址）</span>&#125;<span class="hljs-comment">// LinkedList</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LList</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">&#x27;head&#x27;</span>); <span class="hljs-comment">// 实例化一个头节点</span>  <span class="hljs-built_in">this</span>.find = find; <span class="hljs-comment">// 查找</span>  <span class="hljs-built_in">this</span>.insert = insert; <span class="hljs-comment">// 插入</span>  <span class="hljs-built_in">this</span>.remove = remove; <span class="hljs-comment">// 删除</span>  <span class="hljs-built_in">this</span>.display = display; <span class="hljs-comment">// 显示链表里面所有的元素</span>  <span class="hljs-built_in">this</span>.findPrevious = findPrevious;&#125;<span class="hljs-comment">// LList初始状态下。就是 head -&gt; null。相当于数组中的 []，不包含任何元素。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">element</span>)</span>&#123;  <span class="hljs-comment">// let eleNode = new Node(element);</span>    <span class="hljs-keyword">let</span> curNode = <span class="hljs-built_in">this</span>.head; <span class="hljs-comment">// 头节点</span>    <span class="hljs-keyword">while</span>(curNode.element != eleNode)&#123;      curNode = curNode.next;    &#125;    <span class="hljs-keyword">return</span> curNode;&#125;<span class="hljs-comment">// 在item后插入newElement</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span>(<span class="hljs-params">newElement, item</span>)</span>&#123;  <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(newElement);  <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.find(item);  newNode.next = current.next;  current.next = newNode;&#125;<span class="hljs-comment">//display</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> curr = <span class="hljs-built_in">this</span>.head; <span class="hljs-comment">// 从头开始</span>  <span class="hljs-keyword">while</span>(curr.next != <span class="hljs-literal">null</span>)&#123;    <span class="hljs-built_in">console</span>.log(curr.next.element);    curr =  curr.next;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPrevious</span>(<span class="hljs-params">element</span>)</span>&#123;  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;  <span class="hljs-comment">// 还没到最后一个元素，并且下一个元素不是element就继续next</span>  <span class="hljs-comment">// 进行查找。cur.next = element;此时cur就是element的</span>  <span class="hljs-comment">// 前一个元素</span>  <span class="hljs-keyword">if</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.element != element)&#123;    cur = cur.next;  &#125;  <span class="hljs-keyword">return</span> cur;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">element</span>)</span>&#123;  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.findPrevious(element);  <span class="hljs-keyword">if</span>(cur.next != <span class="hljs-literal">null</span>)&#123;    <span class="hljs-comment">// cur.next = element.next; 为什么这样写不行？</span>    cur.next = cur.next.next;  &#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">var</span> cities = <span class="hljs-keyword">new</span> LList();cities.insert(<span class="hljs-string">&quot;ShenZhen&quot;</span>, <span class="hljs-string">&quot;head&quot;</span>);cities.insert(<span class="hljs-string">&quot;HangZhou&quot;</span>, <span class="hljs-string">&quot;Xihu&quot;</span>);cities.insert(<span class="hljs-string">&quot;SiChuan&quot;</span>, <span class="hljs-string">&quot;Chengdu&quot;</span>);cities.display();<span class="hljs-comment">// 双链表</span></code></pre></li></ul><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><code>双链表</code>中的元素具有指向<code>前一个元素</code>和<code>后一个元素</code>的<code>链</code>，相比单链表多了一个<code>指向前一个元素的链</code>。</p><p><strong>三条线</strong></p><ol><li>current.next</li><li>current.previous</li><li>previous.next -&gt; current<pre><code class="hljs js"><span class="hljs-comment">//修改Node类，增加previous属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">element</span>)</span>&#123;  <span class="hljs-built_in">this</span>.element = element;  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.previous = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">//修改insert</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span>(<span class="hljs-params">newElement, item</span>)</span>&#123;  <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(newElement); <span class="hljs-comment">// 新增节点</span>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.find(item); <span class="hljs-comment">// 要追加节点的位置</span>  cur.next = newNode;  newNode.previous = cur;  newNode.next = cur.next;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">element</span>)</span>&#123;  <span class="hljs-keyword">let</span> curr = <span class="hljs-built_in">this</span>.find(element); <span class="hljs-comment">//找到要删除的节点位置</span>  <span class="hljs-keyword">if</span>(curr.next != <span class="hljs-literal">null</span>)&#123;    curr.previous.next = curr.next; <span class="hljs-comment">//上节点指向下节点</span>    curr.next.previous = curr.previous; <span class="hljs-comment">// 下节点指向上节点</span>    curr.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 删除当前节点下链接</span>    curr.previous = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 删除当前节点上链接</span>  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLast</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// let cur = this.find();</span>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;  <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;    cur = cur.next;  &#125;  <span class="hljs-keyword">return</span> cur;&#125;<span class="hljs-comment">// 反序显示</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispReverse</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> curNode = <span class="hljs-built_in">this</span>.head;  curNode = <span class="hljs-built_in">this</span>.findPrevious();  <span class="hljs-keyword">while</span>(curNode.previous != <span class="hljs-literal">null</span>)&#123;    <span class="hljs-built_in">console</span>.log(curNode.element);    curNode = curNode.previous;  &#125;&#125;</code></pre></li></ol><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote><p>如果你希望可以从后向前遍历链表，但是又不想付出额外的代价来创建一个双向链表，那么<br>就需要使用循环链表，从<code>循环链表</code>的尾结点向后移动，就等于从后向前遍历链表。</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LList</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">&#x27;head&#x27;</span>);  <span class="hljs-built_in">this</span>.head.next = <span class="hljs-built_in">this</span>.head;  <span class="hljs-built_in">this</span>.find = find;  <span class="hljs-built_in">this</span>.insert = insert;  <span class="hljs-built_in">this</span>.findPrevious = findPrevious;  <span class="hljs-built_in">this</span>.remove = remove;  <span class="hljs-built_in">this</span>.display = display;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> cur = <span class="hljs-built_in">this</span>.head;  <span class="hljs-comment">// 检查到头节点退出。不然就会死循环。</span>  <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.element != <span class="hljs-string">&#x27;head&#x27;</span>)&#123;    cur = cur.next;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的数据结构</title>
    <link href="/2020/12/08/js-algorithm/"/>
    <url>/2020/12/08/js-algorithm/</url>
    
    <content type="html"><![CDATA[<p>作为前端开发,在日常工作中主要处理的都是产品的展示,接触最多的是UI库,比较少用到数据结构与算法,但是在编程中,更多的了解和学习数据结构与算法对我们的编码和处理性能问题提供保障.笔者写这个专题旨在记录自己的学习过程和总结.</p><h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><ul><li>列表</li><li>栈</li><li>队列</li><li>链表<ul><li>单链表</li><li>双链表</li></ul></li><li>二叉树</li><li>图</li></ul><h3 id="列表的实现"><a href="#列表的实现" class="headerlink" title="列表的实现"></a>列表的实现</h3><p>使用Array实现列表</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.dataSource = [];    <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;    <span class="hljs-built_in">this</span>.append = append;    <span class="hljs-built_in">this</span>.remove = remove;    <span class="hljs-built_in">this</span>.clear = clear;    <span class="hljs-built_in">this</span>.length = length;    <span class="hljs-built_in">this</span>.find = find;    <span class="hljs-built_in">this</span>.contains = contains;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
